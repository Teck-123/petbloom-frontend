# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'ggciceaie',
                'name': 'bbehjachib',
                'firebaseUid': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'dgiiaaijj',
                    'name': 'bfaiacjjfc',
                    'firebaseUid': 'eigcfgbif',
                },
                {
                    # data to create a User record
                    'email': 'bagcfbhiig',
                    'name': 'cghideieh',
                    'firebaseUid': 'biabhbdai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'idghgaicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'fjfddhigg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the name field
        users = await User.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the firebaseUid field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'firebaseUid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the phone field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'phone': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'cbbbjbfcii',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bbejhfidcb',
            },
            data={
                'create': {
                    'id': 'bbejhfidcb',
                    'email': 'bagcfbhiig',
                    'name': 'cghideieh',
                    'firebaseUid': 'biabhbdai',
                },
                'update': {
                    'email': 'bagcfbhiig',
                    'name': 'cghideieh',
                    'firebaseUid': 'biabhbdai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'address': 'bgeecijdgg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'city': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'state': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by zipCode values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['zipCode'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PetActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Pet]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Pet.prisma().query_raw(
            'SELECT * FROM Pet WHERE id = $1',
            'bdiicjafbj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Pet
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Pet.prisma().query_first(
            'SELECT * FROM Pet WHERE name = $1',
            'bgehebiafc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PetCreateInput,
        include: Optional[types.PetInclude] = None
    ) -> _PrismaModelT:
        """Create a new Pet record.

        Parameters
        ----------
        data
            Pet record data
        include
            Specifies which relations should be loaded on the returned Pet model

        Returns
        -------
        prisma.models.Pet
            The created Pet record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Pet record from just the required fields
        pet = await Pet.prisma().create(
            data={
                # data to create a Pet record
                'name': 'bghffegacj',
                'species': 'bhghchehcc',
                'breed': 'dcgchcbbf',
                'age': 1343201072,
                'breederName': 'ghfhiafcb',
                'price': 744964398.196968,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PetCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Pet records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Pet record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Pet.prisma().create_many(
            data=[
                {
                    # data to create a Pet record
                    'name': 'bbbgbhfjge',
                    'species': 'igbehcbab',
                    'breed': 'bdadaadhag',
                    'age': 1686638315,
                    'breederName': 'caaaedabfc',
                    'price': 1868141281.186084,
                },
                {
                    # data to create a Pet record
                    'name': 'beeifcbebf',
                    'species': 'bgcigfahea',
                    'breed': 'bcejgaggif',
                    'age': 835903122,
                    'breederName': 'hgdhbjhhj',
                    'price': 429995104.177581,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PetWhereUniqueInput,
        include: Optional[types.PetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Pet record.

        Parameters
        ----------
        where
            Pet filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Pet model

        Returns
        -------
        prisma.models.Pet
            The deleted Pet record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pet = await Pet.prisma().delete(
            where={
                'id': 'ijdbeffgg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PetWhereUniqueInput,
        include: Optional[types.PetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Pet record.

        Parameters
        ----------
        where
            Pet filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Pet model

        Returns
        -------
        prisma.models.Pet
            The found Pet record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pet = await Pet.prisma().find_unique(
            where={
                'id': 'jjfeafhfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PetWhereUniqueInput,
        include: Optional[types.PetInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Pet record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Pet filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Pet model

        Returns
        -------
        prisma.models.Pet
            The found Pet record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pet = await Pet.prisma().find_unique_or_raise(
            where={
                'id': 'cbachdgfce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PetWhereInput] = None,
        cursor: Optional[types.PetWhereUniqueInput] = None,
        include: Optional[types.PetInclude] = None,
        order: Optional[Union[types.PetOrderByInput, List[types.PetOrderByInput]]] = None,
        distinct: Optional[List[types.PetScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Pet records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Pet records returned
        skip
            Ignore the first N results
        where
            Pet filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Pet model
        order
            Order the returned Pet records by any field
        distinct
            Filter Pet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Pet]
            The list of all Pet records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Pet records
        pets = await Pet.prisma().find_many(take=10)

        # find the first 5 Pet records ordered by the species field
        pets = await Pet.prisma().find_many(
            take=5,
            order={
                'species': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PetWhereInput] = None,
        cursor: Optional[types.PetWhereUniqueInput] = None,
        include: Optional[types.PetInclude] = None,
        order: Optional[Union[types.PetOrderByInput, List[types.PetOrderByInput]]] = None,
        distinct: Optional[List[types.PetScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Pet record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Pet filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Pet model
        order
            Order the returned Pet records by any field
        distinct
            Filter Pet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Pet
            The first Pet record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Pet record ordered by the breed field
        pet = await Pet.prisma().find_first(
            skip=1,
            order={
                'breed': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PetWhereInput] = None,
        cursor: Optional[types.PetWhereUniqueInput] = None,
        include: Optional[types.PetInclude] = None,
        order: Optional[Union[types.PetOrderByInput, List[types.PetOrderByInput]]] = None,
        distinct: Optional[List[types.PetScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Pet record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Pet filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Pet model
        order
            Order the returned Pet records by any field
        distinct
            Filter Pet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Pet
            The first Pet record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Pet record ordered by the age field
        pet = await Pet.prisma().find_first_or_raise(
            skip=1,
            order={
                'age': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PetUpdateInput,
        where: types.PetWhereUniqueInput,
        include: Optional[types.PetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Pet record.

        Parameters
        ----------
        data
            Pet record data specifying what to update
        where
            Pet filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Pet model

        Returns
        -------
        prisma.models.Pet
            The updated Pet record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        pet = await Pet.prisma().update(
            where={
                'id': 'chbfcacbd',
            },
            data={
                # data to update the Pet record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PetWhereUniqueInput,
        data: types.PetUpsertInput,
        include: Optional[types.PetInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Pet filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Pet model

        Returns
        -------
        prisma.models.Pet
            The created or updated Pet record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pet = await Pet.prisma().upsert(
            where={
                'id': 'efggddide',
            },
            data={
                'create': {
                    'id': 'efggddide',
                    'name': 'beeifcbebf',
                    'species': 'bgcigfahea',
                    'breed': 'bcejgaggif',
                    'age': 835903122,
                    'breederName': 'hgdhbjhhj',
                    'price': 429995104.177581,
                },
                'update': {
                    'name': 'beeifcbebf',
                    'species': 'bgcigfahea',
                    'breed': 'bcejgaggif',
                    'age': 835903122,
                    'breederName': 'hgdhbjhhj',
                    'price': 429995104.177581,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PetUpdateManyMutationInput,
        where: types.PetWhereInput,
    ) -> int:
        """Update multiple Pet records

        Parameters
        ----------
        data
            Pet data to update the selected Pet records to
        where
            Filter to select the Pet records to update

        Returns
        -------
        int
            The total number of Pet records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Pet records
        total = await Pet.prisma().update_many(
            data={
                'weight': 2058258651.158368
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PetWhereInput] = None,
        cursor: Optional[types.PetWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Pet records present in the database

        Parameters
        ----------
        select
            Select the Pet fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Pet filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Pet.prisma().count()

        # results: prisma.types.PetCountAggregateOutput
        results = await Pet.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PetCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PetWhereInput] = None,
        cursor: Optional[types.PetWhereUniqueInput] = None,
    ) -> types.PetCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PetCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PetWhereInput] = None,
        cursor: Optional[types.PetWhereUniqueInput] = None,
    ) -> Union[int, types.PetCountAggregateOutput]:
        """Count the number of Pet records present in the database

        Parameters
        ----------
        select
            Select the Pet fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Pet filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Pet.prisma().count()

        # results: prisma.types.PetCountAggregateOutput
        results = await Pet.prisma().count(
            select={
                '_all': True,
                'images': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PetCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PetWhereInput] = None
    ) -> int:
        """Delete multiple Pet records.

        Parameters
        ----------
        where
            Optional Pet filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Pet records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Pet records
        total = await Pet.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PetScalarFieldKeys'],
        *,
        where: Optional['types.PetWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PetAvgAggregateInput'] = None,
        sum: Optional['types.PetSumAggregateInput'] = None,
        min: Optional['types.PetMinAggregateInput'] = None,
        max: Optional['types.PetMaxAggregateInput'] = None,
        having: Optional['types.PetScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PetCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PetScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PetScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PetGroupByOutput']:
        """Group Pet records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Pet fields to group records by
        where
            Pet filter to select records
        take
            Limit the maximum number of Pet records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PetGroupByOutput]
            A list of dictionaries representing the Pet record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Pet records by videos values
        # and count how many records are in each group
        results = await Pet.prisma().group_by(
            ['videos'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProductActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Product]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Product.prisma().query_raw(
            'SELECT * FROM Product WHERE id = $1',
            'ihieecagf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Product
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Product.prisma().query_first(
            'SELECT * FROM Product WHERE name = $1',
            'bghfciaafe',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProductCreateInput,
        include: Optional[types.ProductInclude] = None
    ) -> _PrismaModelT:
        """Create a new Product record.

        Parameters
        ----------
        data
            Product record data
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The created Product record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Product record from just the required fields
        product = await Product.prisma().create(
            data={
                # data to create a Product record
                'name': 'bgchfhgceh',
                'category': 'cafeiaccbc',
                'price': 60335757.68446,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProductCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Product records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Product record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Product.prisma().create_many(
            data=[
                {
                    # data to create a Product record
                    'name': 'bgcffadich',
                    'category': 'fcbichhci',
                    'price': 1266032265.9325,
                },
                {
                    # data to create a Product record
                    'name': 'cafdaehjid',
                    'category': 'gifdddbia',
                    'price': 127474245.94892,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Product record.

        Parameters
        ----------
        where
            Product filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The deleted Product record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().delete(
            where={
                'id': 'bjgejjabff',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Product record.

        Parameters
        ----------
        where
            Product filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The found Product record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().find_unique(
            where={
                'id': 'bcciijbibg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Product record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Product filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The found Product record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().find_unique_or_raise(
            where={
                'id': 'cffcachfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Product records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Product records returned
        skip
            Ignore the first N results
        where
            Product filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Product]
            The list of all Product records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Product records
        products = await Product.prisma().find_many(take=10)

        # find the first 5 Product records ordered by the description field
        products = await Product.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Product record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Product filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Product
            The first Product record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Product record ordered by the category field
        product = await Product.prisma().find_first(
            skip=1,
            order={
                'category': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Product record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Product filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Product
            The first Product record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Product record ordered by the petType field
        product = await Product.prisma().find_first_or_raise(
            skip=1,
            order={
                'petType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProductUpdateInput,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Product record.

        Parameters
        ----------
        data
            Product record data specifying what to update
        where
            Product filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The updated Product record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        product = await Product.prisma().update(
            where={
                'id': 'bccdfhdigc',
            },
            data={
                # data to update the Product record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProductWhereUniqueInput,
        data: types.ProductUpsertInput,
        include: Optional[types.ProductInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Product filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The created or updated Product record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().upsert(
            where={
                'id': 'febcgjbfj',
            },
            data={
                'create': {
                    'id': 'febcgjbfj',
                    'name': 'cafdaehjid',
                    'category': 'gifdddbia',
                    'price': 127474245.94892,
                },
                'update': {
                    'name': 'cafdaehjid',
                    'category': 'gifdddbia',
                    'price': 127474245.94892,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProductUpdateManyMutationInput,
        where: types.ProductWhereInput,
    ) -> int:
        """Update multiple Product records

        Parameters
        ----------
        data
            Product data to update the selected Product records to
        where
            Filter to select the Product records to update

        Returns
        -------
        int
            The total number of Product records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Product records
        total = await Product.prisma().update_many(
            data={
                'brand': 'bageiegghg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Product records present in the database

        Parameters
        ----------
        select
            Select the Product fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Product filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Product.prisma().count()

        # results: prisma.types.ProductCountAggregateOutput
        results = await Product.prisma().count(
            select={
                '_all': True,
                'price': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProductCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> types.ProductCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProductCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> Union[int, types.ProductCountAggregateOutput]:
        """Count the number of Product records present in the database

        Parameters
        ----------
        select
            Select the Product fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Product filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Product.prisma().count()

        # results: prisma.types.ProductCountAggregateOutput
        results = await Product.prisma().count(
            select={
                '_all': True,
                'images': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProductCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProductWhereInput] = None
    ) -> int:
        """Delete multiple Product records.

        Parameters
        ----------
        where
            Optional Product filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Product records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Product records
        total = await Product.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProductScalarFieldKeys'],
        *,
        where: Optional['types.ProductWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProductAvgAggregateInput'] = None,
        sum: Optional['types.ProductSumAggregateInput'] = None,
        min: Optional['types.ProductMinAggregateInput'] = None,
        max: Optional['types.ProductMaxAggregateInput'] = None,
        having: Optional['types.ProductScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProductCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProductScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProductScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProductGroupByOutput']:
        """Group Product records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Product fields to group records by
        where
            Product filter to select records
        take
            Limit the maximum number of Product records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProductGroupByOutput]
            A list of dictionaries representing the Product record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Product records by stock values
        # and count how many records are in each group
        results = await Product.prisma().group_by(
            ['stock'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CartItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CartItem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await CartItem.prisma().query_raw(
            'SELECT * FROM CartItem WHERE id = $1',
            'faidicegb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CartItem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await CartItem.prisma().query_first(
            'SELECT * FROM CartItem WHERE userId = $1',
            'bacecgfhbe',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CartItemCreateInput,
        include: Optional[types.CartItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new CartItem record.

        Parameters
        ----------
        data
            CartItem record data
        include
            Specifies which relations should be loaded on the returned CartItem model

        Returns
        -------
        prisma.models.CartItem
            The created CartItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CartItem record from just the required fields
        cartitem = await CartItem.prisma().create(
            data={
                # data to create a CartItem record
                'userId': 'ihcahiead',
                'price': 1874748096.91689,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CartItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CartItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CartItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CartItem.prisma().create_many(
            data=[
                {
                    # data to create a CartItem record
                    'userId': 'hgjcghfbi',
                    'price': 820312479.9272,
                },
                {
                    # data to create a CartItem record
                    'userId': 'deeificjd',
                    'price': 1121741130.149589,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CartItemWhereUniqueInput,
        include: Optional[types.CartItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CartItem record.

        Parameters
        ----------
        where
            CartItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CartItem model

        Returns
        -------
        prisma.models.CartItem
            The deleted CartItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cartitem = await CartItem.prisma().delete(
            where={
                'id': 'caifcbgii',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CartItemWhereUniqueInput,
        include: Optional[types.CartItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CartItem record.

        Parameters
        ----------
        where
            CartItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CartItem model

        Returns
        -------
        prisma.models.CartItem
            The found CartItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cartitem = await CartItem.prisma().find_unique(
            where={
                'id': 'igaibbfgj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CartItemWhereUniqueInput,
        include: Optional[types.CartItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CartItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CartItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CartItem model

        Returns
        -------
        prisma.models.CartItem
            The found CartItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cartitem = await CartItem.prisma().find_unique_or_raise(
            where={
                'id': 'bggajdcbbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CartItemWhereInput] = None,
        cursor: Optional[types.CartItemWhereUniqueInput] = None,
        include: Optional[types.CartItemInclude] = None,
        order: Optional[Union[types.CartItemOrderByInput, List[types.CartItemOrderByInput]]] = None,
        distinct: Optional[List[types.CartItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CartItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CartItem records returned
        skip
            Ignore the first N results
        where
            CartItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CartItem model
        order
            Order the returned CartItem records by any field
        distinct
            Filter CartItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CartItem]
            The list of all CartItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CartItem records
        cartitems = await CartItem.prisma().find_many(take=10)

        # find the first 5 CartItem records ordered by the productId field
        cartitems = await CartItem.prisma().find_many(
            take=5,
            order={
                'productId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CartItemWhereInput] = None,
        cursor: Optional[types.CartItemWhereUniqueInput] = None,
        include: Optional[types.CartItemInclude] = None,
        order: Optional[Union[types.CartItemOrderByInput, List[types.CartItemOrderByInput]]] = None,
        distinct: Optional[List[types.CartItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CartItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CartItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CartItem model
        order
            Order the returned CartItem records by any field
        distinct
            Filter CartItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CartItem
            The first CartItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CartItem record ordered by the petId field
        cartitem = await CartItem.prisma().find_first(
            skip=1,
            order={
                'petId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CartItemWhereInput] = None,
        cursor: Optional[types.CartItemWhereUniqueInput] = None,
        include: Optional[types.CartItemInclude] = None,
        order: Optional[Union[types.CartItemOrderByInput, List[types.CartItemOrderByInput]]] = None,
        distinct: Optional[List[types.CartItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CartItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CartItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CartItem model
        order
            Order the returned CartItem records by any field
        distinct
            Filter CartItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CartItem
            The first CartItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CartItem record ordered by the quantity field
        cartitem = await CartItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CartItemUpdateInput,
        where: types.CartItemWhereUniqueInput,
        include: Optional[types.CartItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CartItem record.

        Parameters
        ----------
        data
            CartItem record data specifying what to update
        where
            CartItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CartItem model

        Returns
        -------
        prisma.models.CartItem
            The updated CartItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        cartitem = await CartItem.prisma().update(
            where={
                'id': 'fcfhgbjed',
            },
            data={
                # data to update the CartItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CartItemWhereUniqueInput,
        data: types.CartItemUpsertInput,
        include: Optional[types.CartItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CartItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CartItem model

        Returns
        -------
        prisma.models.CartItem
            The created or updated CartItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cartitem = await CartItem.prisma().upsert(
            where={
                'id': 'hdgcajhjg',
            },
            data={
                'create': {
                    'id': 'hdgcajhjg',
                    'userId': 'deeificjd',
                    'price': 1121741130.149589,
                },
                'update': {
                    'userId': 'deeificjd',
                    'price': 1121741130.149589,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CartItemUpdateManyMutationInput,
        where: types.CartItemWhereInput,
    ) -> int:
        """Update multiple CartItem records

        Parameters
        ----------
        data
            CartItem data to update the selected CartItem records to
        where
            Filter to select the CartItem records to update

        Returns
        -------
        int
            The total number of CartItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CartItem records
        total = await CartItem.prisma().update_many(
            data={
                'price': 493907821.63968
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CartItemWhereInput] = None,
        cursor: Optional[types.CartItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CartItem records present in the database

        Parameters
        ----------
        select
            Select the CartItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CartItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CartItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CartItem.prisma().count()

        # results: prisma.types.CartItemCountAggregateOutput
        results = await CartItem.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CartItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CartItemWhereInput] = None,
        cursor: Optional[types.CartItemWhereUniqueInput] = None,
    ) -> types.CartItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CartItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CartItemWhereInput] = None,
        cursor: Optional[types.CartItemWhereUniqueInput] = None,
    ) -> Union[int, types.CartItemCountAggregateOutput]:
        """Count the number of CartItem records present in the database

        Parameters
        ----------
        select
            Select the CartItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CartItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CartItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CartItem.prisma().count()

        # results: prisma.types.CartItemCountAggregateOutput
        results = await CartItem.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CartItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CartItemWhereInput] = None
    ) -> int:
        """Delete multiple CartItem records.

        Parameters
        ----------
        where
            Optional CartItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CartItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CartItem records
        total = await CartItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CartItemScalarFieldKeys'],
        *,
        where: Optional['types.CartItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CartItemAvgAggregateInput'] = None,
        sum: Optional['types.CartItemSumAggregateInput'] = None,
        min: Optional['types.CartItemMinAggregateInput'] = None,
        max: Optional['types.CartItemMaxAggregateInput'] = None,
        having: Optional['types.CartItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CartItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CartItemScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CartItemScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CartItemGroupByOutput']:
        """Group CartItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CartItem fields to group records by
        where
            CartItem filter to select records
        take
            Limit the maximum number of CartItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CartItemGroupByOutput]
            A list of dictionaries representing the CartItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CartItem records by id values
        # and count how many records are in each group
        results = await CartItem.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WishlistActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Wishlist]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Wishlist.prisma().query_raw(
            'SELECT * FROM Wishlist WHERE id = $1',
            'gfeaahdeh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Wishlist
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Wishlist.prisma().query_first(
            'SELECT * FROM Wishlist WHERE userId = $1',
            'bjafcgbffc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WishlistCreateInput,
        include: Optional[types.WishlistInclude] = None
    ) -> _PrismaModelT:
        """Create a new Wishlist record.

        Parameters
        ----------
        data
            Wishlist record data
        include
            Specifies which relations should be loaded on the returned Wishlist model

        Returns
        -------
        prisma.models.Wishlist
            The created Wishlist record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Wishlist record from just the required fields
        wishlist = await Wishlist.prisma().create(
            data={
                # data to create a Wishlist record
                'userId': 'hihegjif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WishlistCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Wishlist records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Wishlist record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Wishlist.prisma().create_many(
            data=[
                {
                    # data to create a Wishlist record
                    'userId': 'bdjidcidac',
                },
                {
                    # data to create a Wishlist record
                    'userId': 'ifgaaagff',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WishlistWhereUniqueInput,
        include: Optional[types.WishlistInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Wishlist record.

        Parameters
        ----------
        where
            Wishlist filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Wishlist model

        Returns
        -------
        prisma.models.Wishlist
            The deleted Wishlist record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        wishlist = await Wishlist.prisma().delete(
            where={
                'id': 'befcddgjce',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WishlistWhereUniqueInput,
        include: Optional[types.WishlistInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Wishlist record.

        Parameters
        ----------
        where
            Wishlist filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Wishlist model

        Returns
        -------
        prisma.models.Wishlist
            The found Wishlist record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        wishlist = await Wishlist.prisma().find_unique(
            where={
                'id': 'bfhdbjjgfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WishlistWhereUniqueInput,
        include: Optional[types.WishlistInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Wishlist record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Wishlist filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Wishlist model

        Returns
        -------
        prisma.models.Wishlist
            The found Wishlist record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        wishlist = await Wishlist.prisma().find_unique_or_raise(
            where={
                'id': 'cabdjadaji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WishlistWhereInput] = None,
        cursor: Optional[types.WishlistWhereUniqueInput] = None,
        include: Optional[types.WishlistInclude] = None,
        order: Optional[Union[types.WishlistOrderByInput, List[types.WishlistOrderByInput]]] = None,
        distinct: Optional[List[types.WishlistScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Wishlist records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Wishlist records returned
        skip
            Ignore the first N results
        where
            Wishlist filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Wishlist model
        order
            Order the returned Wishlist records by any field
        distinct
            Filter Wishlist records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Wishlist]
            The list of all Wishlist records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Wishlist records
        wishlists = await Wishlist.prisma().find_many(take=10)

        # find the first 5 Wishlist records ordered by the productId field
        wishlists = await Wishlist.prisma().find_many(
            take=5,
            order={
                'productId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WishlistWhereInput] = None,
        cursor: Optional[types.WishlistWhereUniqueInput] = None,
        include: Optional[types.WishlistInclude] = None,
        order: Optional[Union[types.WishlistOrderByInput, List[types.WishlistOrderByInput]]] = None,
        distinct: Optional[List[types.WishlistScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Wishlist record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Wishlist filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Wishlist model
        order
            Order the returned Wishlist records by any field
        distinct
            Filter Wishlist records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Wishlist
            The first Wishlist record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Wishlist record ordered by the petId field
        wishlist = await Wishlist.prisma().find_first(
            skip=1,
            order={
                'petId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WishlistWhereInput] = None,
        cursor: Optional[types.WishlistWhereUniqueInput] = None,
        include: Optional[types.WishlistInclude] = None,
        order: Optional[Union[types.WishlistOrderByInput, List[types.WishlistOrderByInput]]] = None,
        distinct: Optional[List[types.WishlistScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Wishlist record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Wishlist filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Wishlist model
        order
            Order the returned Wishlist records by any field
        distinct
            Filter Wishlist records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Wishlist
            The first Wishlist record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Wishlist record ordered by the addedAt field
        wishlist = await Wishlist.prisma().find_first_or_raise(
            skip=1,
            order={
                'addedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WishlistUpdateInput,
        where: types.WishlistWhereUniqueInput,
        include: Optional[types.WishlistInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Wishlist record.

        Parameters
        ----------
        data
            Wishlist record data specifying what to update
        where
            Wishlist filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Wishlist model

        Returns
        -------
        prisma.models.Wishlist
            The updated Wishlist record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        wishlist = await Wishlist.prisma().update(
            where={
                'id': 'faajgfadf',
            },
            data={
                # data to update the Wishlist record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WishlistWhereUniqueInput,
        data: types.WishlistUpsertInput,
        include: Optional[types.WishlistInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Wishlist filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Wishlist model

        Returns
        -------
        prisma.models.Wishlist
            The created or updated Wishlist record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        wishlist = await Wishlist.prisma().upsert(
            where={
                'id': 'biaagcedjc',
            },
            data={
                'create': {
                    'id': 'biaagcedjc',
                    'userId': 'ifgaaagff',
                },
                'update': {
                    'userId': 'ifgaaagff',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WishlistUpdateManyMutationInput,
        where: types.WishlistWhereInput,
    ) -> int:
        """Update multiple Wishlist records

        Parameters
        ----------
        data
            Wishlist data to update the selected Wishlist records to
        where
            Filter to select the Wishlist records to update

        Returns
        -------
        int
            The total number of Wishlist records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Wishlist records
        total = await Wishlist.prisma().update_many(
            data={
                'id': 'cahhaghecf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WishlistWhereInput] = None,
        cursor: Optional[types.WishlistWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Wishlist records present in the database

        Parameters
        ----------
        select
            Select the Wishlist fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Wishlist filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WishlistCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Wishlist.prisma().count()

        # results: prisma.types.WishlistCountAggregateOutput
        results = await Wishlist.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WishlistCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WishlistWhereInput] = None,
        cursor: Optional[types.WishlistWhereUniqueInput] = None,
    ) -> types.WishlistCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WishlistCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WishlistWhereInput] = None,
        cursor: Optional[types.WishlistWhereUniqueInput] = None,
    ) -> Union[int, types.WishlistCountAggregateOutput]:
        """Count the number of Wishlist records present in the database

        Parameters
        ----------
        select
            Select the Wishlist fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Wishlist filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WishlistCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Wishlist.prisma().count()

        # results: prisma.types.WishlistCountAggregateOutput
        results = await Wishlist.prisma().count(
            select={
                '_all': True,
                'productId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WishlistCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WishlistWhereInput] = None
    ) -> int:
        """Delete multiple Wishlist records.

        Parameters
        ----------
        where
            Optional Wishlist filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Wishlist records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Wishlist records
        total = await Wishlist.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WishlistScalarFieldKeys'],
        *,
        where: Optional['types.WishlistWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WishlistAvgAggregateInput'] = None,
        sum: Optional['types.WishlistSumAggregateInput'] = None,
        min: Optional['types.WishlistMinAggregateInput'] = None,
        max: Optional['types.WishlistMaxAggregateInput'] = None,
        having: Optional['types.WishlistScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WishlistCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WishlistScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WishlistScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WishlistGroupByOutput']:
        """Group Wishlist records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Wishlist fields to group records by
        where
            Wishlist filter to select records
        take
            Limit the maximum number of Wishlist records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WishlistGroupByOutput]
            A list of dictionaries representing the Wishlist record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Wishlist records by petId values
        # and count how many records are in each group
        results = await Wishlist.prisma().group_by(
            ['petId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrderActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Order]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Order.prisma().query_raw(
            'SELECT * FROM Order WHERE id = $1',
            'bghcbbcidi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Order
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Order.prisma().query_first(
            'SELECT * FROM Order WHERE userId = $1',
            'jcgghhgdj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrderCreateInput,
        include: Optional[types.OrderInclude] = None
    ) -> _PrismaModelT:
        """Create a new Order record.

        Parameters
        ----------
        data
            Order record data
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The created Order record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Order record from just the required fields
        order = await Order.prisma().create(
            data={
                # data to create a Order record
                'userId': 'beehgcebbg',
                'totalPrice': 1738083805.34094,
                'shippingAddress': 'gabahhhjf',
                'deliveryOption': 'cjagadcjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrderCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Order records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Order record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Order.prisma().create_many(
            data=[
                {
                    # data to create a Order record
                    'userId': 'bifficggej',
                    'totalPrice': 1611009182.44667,
                    'shippingAddress': 'daafgidjg',
                    'deliveryOption': 'gdcgcgagj',
                },
                {
                    # data to create a Order record
                    'userId': 'bhceabbgja',
                    'totalPrice': 470157467.120920,
                    'shippingAddress': 'bfdgheeegf',
                    'deliveryOption': 'ececbijji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Order record.

        Parameters
        ----------
        where
            Order filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The deleted Order record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().delete(
            where={
                'id': 'cbcfgdcdhf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Order record.

        Parameters
        ----------
        where
            Order filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The found Order record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().find_unique(
            where={
                'id': 'fdgjfbhia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Order record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Order filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The found Order record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().find_unique_or_raise(
            where={
                'id': 'jcehcdchh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Order records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Order records returned
        skip
            Ignore the first N results
        where
            Order filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Order]
            The list of all Order records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Order records
        orders = await Order.prisma().find_many(take=10)

        # find the first 5 Order records ordered by the status field
        orders = await Order.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Order record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Order filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Order
            The first Order record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Order record ordered by the totalPrice field
        order = await Order.prisma().find_first(
            skip=1,
            order={
                'totalPrice': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Order record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Order filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Order
            The first Order record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Order record ordered by the shippingAddress field
        order = await Order.prisma().find_first_or_raise(
            skip=1,
            order={
                'shippingAddress': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrderUpdateInput,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Order record.

        Parameters
        ----------
        data
            Order record data specifying what to update
        where
            Order filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The updated Order record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        order = await Order.prisma().update(
            where={
                'id': 'bgcbjdhjcc',
            },
            data={
                # data to update the Order record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrderWhereUniqueInput,
        data: types.OrderUpsertInput,
        include: Optional[types.OrderInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Order filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The created or updated Order record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().upsert(
            where={
                'id': 'bieiidcabj',
            },
            data={
                'create': {
                    'id': 'bieiidcabj',
                    'userId': 'bhceabbgja',
                    'totalPrice': 470157467.120920,
                    'shippingAddress': 'bfdgheeegf',
                    'deliveryOption': 'ececbijji',
                },
                'update': {
                    'userId': 'bhceabbgja',
                    'totalPrice': 470157467.120920,
                    'shippingAddress': 'bfdgheeegf',
                    'deliveryOption': 'ececbijji',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrderUpdateManyMutationInput,
        where: types.OrderWhereInput,
    ) -> int:
        """Update multiple Order records

        Parameters
        ----------
        data
            Order data to update the selected Order records to
        where
            Filter to select the Order records to update

        Returns
        -------
        int
            The total number of Order records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Order records
        total = await Order.prisma().update_many(
            data={
                'deliveryOption': 'bjcbfcieaa'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Order records present in the database

        Parameters
        ----------
        select
            Select the Order fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Order filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Order.prisma().count()

        # results: prisma.types.OrderCountAggregateOutput
        results = await Order.prisma().count(
            select={
                '_all': True,
                'pickupLocation': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrderCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> types.OrderCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrderCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> Union[int, types.OrderCountAggregateOutput]:
        """Count the number of Order records present in the database

        Parameters
        ----------
        select
            Select the Order fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Order filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Order.prisma().count()

        # results: prisma.types.OrderCountAggregateOutput
        results = await Order.prisma().count(
            select={
                '_all': True,
                'trackingNumber': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrderCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrderWhereInput] = None
    ) -> int:
        """Delete multiple Order records.

        Parameters
        ----------
        where
            Optional Order filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Order records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Order records
        total = await Order.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrderScalarFieldKeys'],
        *,
        where: Optional['types.OrderWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrderAvgAggregateInput'] = None,
        sum: Optional['types.OrderSumAggregateInput'] = None,
        min: Optional['types.OrderMinAggregateInput'] = None,
        max: Optional['types.OrderMaxAggregateInput'] = None,
        having: Optional['types.OrderScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrderCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrderScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OrderScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OrderGroupByOutput']:
        """Group Order records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Order fields to group records by
        where
            Order filter to select records
        take
            Limit the maximum number of Order records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrderGroupByOutput]
            A list of dictionaries representing the Order record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Order records by createdAt values
        # and count how many records are in each group
        results = await Order.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrderItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.OrderItem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await OrderItem.prisma().query_raw(
            'SELECT * FROM OrderItem WHERE id = $1',
            'cbaaechiej',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.OrderItem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await OrderItem.prisma().query_first(
            'SELECT * FROM OrderItem WHERE orderId = $1',
            'iejbeaaeg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrderItemCreateInput,
        include: Optional[types.OrderItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new OrderItem record.

        Parameters
        ----------
        data
            OrderItem record data
        include
            Specifies which relations should be loaded on the returned OrderItem model

        Returns
        -------
        prisma.models.OrderItem
            The created OrderItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a OrderItem record from just the required fields
        orderitem = await OrderItem.prisma().create(
            data={
                # data to create a OrderItem record
                'orderId': 'jcibfcbhf',
                'quantity': 273032060,
                'price': 982848517.51073,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrderItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple OrderItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of OrderItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await OrderItem.prisma().create_many(
            data=[
                {
                    # data to create a OrderItem record
                    'orderId': 'cbbheiicgh',
                    'quantity': 1401944936,
                    'price': 1297607553.51948,
                },
                {
                    # data to create a OrderItem record
                    'orderId': 'jhgidcgbf',
                    'quantity': 1696425492,
                    'price': 169262781.102308,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrderItemWhereUniqueInput,
        include: Optional[types.OrderItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single OrderItem record.

        Parameters
        ----------
        where
            OrderItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned OrderItem model

        Returns
        -------
        prisma.models.OrderItem
            The deleted OrderItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        orderitem = await OrderItem.prisma().delete(
            where={
                'id': 'dchgibach',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrderItemWhereUniqueInput,
        include: Optional[types.OrderItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique OrderItem record.

        Parameters
        ----------
        where
            OrderItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OrderItem model

        Returns
        -------
        prisma.models.OrderItem
            The found OrderItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        orderitem = await OrderItem.prisma().find_unique(
            where={
                'id': 'fchheijjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrderItemWhereUniqueInput,
        include: Optional[types.OrderItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique OrderItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            OrderItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OrderItem model

        Returns
        -------
        prisma.models.OrderItem
            The found OrderItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        orderitem = await OrderItem.prisma().find_unique_or_raise(
            where={
                'id': 'cacjdfhejh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderItemWhereInput] = None,
        cursor: Optional[types.OrderItemWhereUniqueInput] = None,
        include: Optional[types.OrderItemInclude] = None,
        order: Optional[Union[types.OrderItemOrderByInput, List[types.OrderItemOrderByInput]]] = None,
        distinct: Optional[List[types.OrderItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple OrderItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of OrderItem records returned
        skip
            Ignore the first N results
        where
            OrderItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrderItem model
        order
            Order the returned OrderItem records by any field
        distinct
            Filter OrderItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.OrderItem]
            The list of all OrderItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 OrderItem records
        orderitems = await OrderItem.prisma().find_many(take=10)

        # find the first 5 OrderItem records ordered by the productId field
        orderitems = await OrderItem.prisma().find_many(
            take=5,
            order={
                'productId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderItemWhereInput] = None,
        cursor: Optional[types.OrderItemWhereUniqueInput] = None,
        include: Optional[types.OrderItemInclude] = None,
        order: Optional[Union[types.OrderItemOrderByInput, List[types.OrderItemOrderByInput]]] = None,
        distinct: Optional[List[types.OrderItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single OrderItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OrderItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrderItem model
        order
            Order the returned OrderItem records by any field
        distinct
            Filter OrderItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OrderItem
            The first OrderItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OrderItem record ordered by the petId field
        orderitem = await OrderItem.prisma().find_first(
            skip=1,
            order={
                'petId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderItemWhereInput] = None,
        cursor: Optional[types.OrderItemWhereUniqueInput] = None,
        include: Optional[types.OrderItemInclude] = None,
        order: Optional[Union[types.OrderItemOrderByInput, List[types.OrderItemOrderByInput]]] = None,
        distinct: Optional[List[types.OrderItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single OrderItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OrderItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrderItem model
        order
            Order the returned OrderItem records by any field
        distinct
            Filter OrderItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OrderItem
            The first OrderItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OrderItem record ordered by the quantity field
        orderitem = await OrderItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrderItemUpdateInput,
        where: types.OrderItemWhereUniqueInput,
        include: Optional[types.OrderItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single OrderItem record.

        Parameters
        ----------
        data
            OrderItem record data specifying what to update
        where
            OrderItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned OrderItem model

        Returns
        -------
        prisma.models.OrderItem
            The updated OrderItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        orderitem = await OrderItem.prisma().update(
            where={
                'id': 'bdbifjhbbi',
            },
            data={
                # data to update the OrderItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrderItemWhereUniqueInput,
        data: types.OrderItemUpsertInput,
        include: Optional[types.OrderItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            OrderItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned OrderItem model

        Returns
        -------
        prisma.models.OrderItem
            The created or updated OrderItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        orderitem = await OrderItem.prisma().upsert(
            where={
                'id': 'cbccbbcdfb',
            },
            data={
                'create': {
                    'id': 'cbccbbcdfb',
                    'orderId': 'jhgidcgbf',
                    'quantity': 1696425492,
                    'price': 169262781.102308,
                },
                'update': {
                    'orderId': 'jhgidcgbf',
                    'quantity': 1696425492,
                    'price': 169262781.102308,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrderItemUpdateManyMutationInput,
        where: types.OrderItemWhereInput,
    ) -> int:
        """Update multiple OrderItem records

        Parameters
        ----------
        data
            OrderItem data to update the selected OrderItem records to
        where
            Filter to select the OrderItem records to update

        Returns
        -------
        int
            The total number of OrderItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all OrderItem records
        total = await OrderItem.prisma().update_many(
            data={
                'price': 1024943020.171730
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderItemWhereInput] = None,
        cursor: Optional[types.OrderItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of OrderItem records present in the database

        Parameters
        ----------
        select
            Select the OrderItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OrderItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OrderItem.prisma().count()

        # results: prisma.types.OrderItemCountAggregateOutput
        results = await OrderItem.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrderItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderItemWhereInput] = None,
        cursor: Optional[types.OrderItemWhereUniqueInput] = None,
    ) -> types.OrderItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrderItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderItemWhereInput] = None,
        cursor: Optional[types.OrderItemWhereUniqueInput] = None,
    ) -> Union[int, types.OrderItemCountAggregateOutput]:
        """Count the number of OrderItem records present in the database

        Parameters
        ----------
        select
            Select the OrderItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OrderItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OrderItem.prisma().count()

        # results: prisma.types.OrderItemCountAggregateOutput
        results = await OrderItem.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrderItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrderItemWhereInput] = None
    ) -> int:
        """Delete multiple OrderItem records.

        Parameters
        ----------
        where
            Optional OrderItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of OrderItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all OrderItem records
        total = await OrderItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrderItemScalarFieldKeys'],
        *,
        where: Optional['types.OrderItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrderItemAvgAggregateInput'] = None,
        sum: Optional['types.OrderItemSumAggregateInput'] = None,
        min: Optional['types.OrderItemMinAggregateInput'] = None,
        max: Optional['types.OrderItemMaxAggregateInput'] = None,
        having: Optional['types.OrderItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrderItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrderItemScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OrderItemScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OrderItemGroupByOutput']:
        """Group OrderItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar OrderItem fields to group records by
        where
            OrderItem filter to select records
        take
            Limit the maximum number of OrderItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrderItemGroupByOutput]
            A list of dictionaries representing the OrderItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group OrderItem records by orderId values
        # and count how many records are in each group
        results = await OrderItem.prisma().group_by(
            ['orderId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models