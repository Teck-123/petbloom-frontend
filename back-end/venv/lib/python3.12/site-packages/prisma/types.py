# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = Literal['default', 'insensitive']
SortOrder = Literal['asc', 'desc']

MetricsFormat = Literal['json', 'prometheus']


class _DatasourceOverrideOptional(TypedDict, total=False):
    env: str
    name: str


class DatasourceOverride(_DatasourceOverrideOptional):
    url: str


# NOTE: we don't support some options as their type hints are not publicly exposed
# https://github.com/encode/httpx/discussions/1977
class HttpConfig(TypedDict, total=False):
    app: Callable[[Mapping[str, Any], Any], Any]
    http1: bool
    http2: bool
    limits: httpx.Limits
    timeout: Union[None, float, httpx.Timeout]
    trust_env: bool
    max_redirects: int


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _str
    phone: Optional[_str]
    address: Optional[_str]
    city: Optional[_str]
    state: Optional[_str]
    zipCode: Optional[_str]
    country: Optional[_str]
    profileImage: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    cartItems: 'CartItemCreateManyNestedWithoutRelationsInput'
    wishlistItems: 'WishlistCreateManyNestedWithoutRelationsInput'
    orders: 'OrderCreateManyNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    email: _str
    name: _str
    firebaseUid: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _str
    phone: Optional[_str]
    address: Optional[_str]
    city: Optional[_str]
    state: Optional[_str]
    zipCode: Optional[_str]
    country: Optional[_str]
    profileImage: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    email: _str
    name: _str
    firebaseUid: _str


class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]


_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

_UserWhereUnique_firebaseUid_Input = TypedDict(
    '_UserWhereUnique_firebaseUid_Input',
    {
        'firebaseUid': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
    '_UserWhereUnique_firebaseUid_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    email: _str
    name: _str
    firebaseUid: _str
    phone: Optional[_str]
    address: Optional[_str]
    city: Optional[_str]
    state: Optional[_str]
    zipCode: Optional[_str]
    country: Optional[_str]
    profileImage: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    cartItems: 'CartItemUpdateManyWithoutRelationsInput'
    wishlistItems: 'WishlistUpdateManyWithoutRelationsInput'
    orders: 'OrderUpdateManyWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    email: _str
    name: _str
    firebaseUid: _str
    phone: Optional[_str]
    address: Optional[_str]
    city: Optional[_str]
    state: Optional[_str]
    zipCode: Optional[_str]
    country: Optional[_str]
    profileImage: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UserCreateOrConnectWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'
    # connectOrCreate: 'UserCreateOrConnectWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_name_OrderByInput = TypedDict(
    '_User_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_User_firebaseUid_OrderByInput = TypedDict(
    '_User_firebaseUid_OrderByInput',
    {
        'firebaseUid': 'SortOrder',
    },
    total=True
)

_User_phone_OrderByInput = TypedDict(
    '_User_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_User_address_OrderByInput = TypedDict(
    '_User_address_OrderByInput',
    {
        'address': 'SortOrder',
    },
    total=True
)

_User_city_OrderByInput = TypedDict(
    '_User_city_OrderByInput',
    {
        'city': 'SortOrder',
    },
    total=True
)

_User_state_OrderByInput = TypedDict(
    '_User_state_OrderByInput',
    {
        'state': 'SortOrder',
    },
    total=True
)

_User_zipCode_OrderByInput = TypedDict(
    '_User_zipCode_OrderByInput',
    {
        'zipCode': 'SortOrder',
    },
    total=True
)

_User_country_OrderByInput = TypedDict(
    '_User_country_OrderByInput',
    {
        'country': 'SortOrder',
    },
    total=True
)

_User_profileImage_OrderByInput = TypedDict(
    '_User_profileImage_OrderByInput',
    {
        'profileImage': 'SortOrder',
    },
    total=True
)

_User_createdAt_OrderByInput = TypedDict(
    '_User_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_User_updatedAt_OrderByInput = TypedDict(
    '_User_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_email_OrderByInput',
    '_User_name_OrderByInput',
    '_User_firebaseUid_OrderByInput',
    '_User_phone_OrderByInput',
    '_User_address_OrderByInput',
    '_User_city_OrderByInput',
    '_User_state_OrderByInput',
    '_User_zipCode_OrderByInput',
    '_User_country_OrderByInput',
    '_User_profileImage_OrderByInput',
    '_User_createdAt_OrderByInput',
    '_User_updatedAt_OrderByInput',
]



# recursive User types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUser']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUser']
    orders: Union[bool, 'FindManyOrderArgsFromUser']


    

class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUserRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUserRecursive1']
    orders: Union[bool, 'FindManyOrderArgsFromUserRecursive1']


class UserIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUserRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUserRecursive2']
    orders: Union[bool, 'FindManyOrderArgsFromUserRecursive2']


class UserIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUserRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUserRecursive3']
    orders: Union[bool, 'FindManyOrderArgsFromUserRecursive3']


class UserIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUserRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUserRecursive4']
    orders: Union[bool, 'FindManyOrderArgsFromUserRecursive4']


class UserIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class PetIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUserRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUserRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromUserRecursive1']


class PetIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUserRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUserRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromUserRecursive2']


class PetIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUserRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUserRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromUserRecursive3']


class PetIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUserRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUserRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromUserRecursive4']


class PetIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class PetArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PetIncludeFromPetRecursive1'


class PetArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'PetIncludeFromPetRecursive2'


class PetArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'PetIncludeFromPetRecursive3'


class PetArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'PetIncludeFromPetRecursive4'


class PetArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyPetArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive1'


class FindManyPetArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive2'


class FindManyPetArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive3'


class FindManyPetArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive4'


class FindManyPetArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    
    

class ProductIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUserRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUserRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromUserRecursive1']


class ProductIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUserRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUserRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromUserRecursive2']


class ProductIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUserRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUserRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromUserRecursive3']


class ProductIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromUserRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromUserRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromUserRecursive4']


class ProductIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class ProductArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ProductIncludeFromProductRecursive1'


class ProductArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'ProductIncludeFromProductRecursive2'


class ProductArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'ProductIncludeFromProductRecursive3'


class ProductArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'ProductIncludeFromProductRecursive4'


class ProductArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyProductArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive1'


class FindManyProductArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive2'


class FindManyProductArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive3'


class FindManyProductArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive4'


class FindManyProductArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    
    

class CartItemIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']
    product: Union[bool, 'ProductArgsFromUserRecursive1']
    pet: Union[bool, 'PetArgsFromUserRecursive1']


class CartItemIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']
    product: Union[bool, 'ProductArgsFromUserRecursive2']
    pet: Union[bool, 'PetArgsFromUserRecursive2']


class CartItemIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']
    product: Union[bool, 'ProductArgsFromUserRecursive3']
    pet: Union[bool, 'PetArgsFromUserRecursive3']


class CartItemIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']
    product: Union[bool, 'ProductArgsFromUserRecursive4']
    pet: Union[bool, 'PetArgsFromUserRecursive4']


class CartItemIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class CartItemArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CartItemIncludeFromCartItemRecursive1'


class CartItemArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'CartItemIncludeFromCartItemRecursive2'


class CartItemArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'CartItemIncludeFromCartItemRecursive3'


class CartItemArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'CartItemIncludeFromCartItemRecursive4'


class CartItemArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyCartItemArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive1'


class FindManyCartItemArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive2'


class FindManyCartItemArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive3'


class FindManyCartItemArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive4'


class FindManyCartItemArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    
    

class WishlistIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']
    product: Union[bool, 'ProductArgsFromUserRecursive1']
    pet: Union[bool, 'PetArgsFromUserRecursive1']


class WishlistIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']
    product: Union[bool, 'ProductArgsFromUserRecursive2']
    pet: Union[bool, 'PetArgsFromUserRecursive2']


class WishlistIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']
    product: Union[bool, 'ProductArgsFromUserRecursive3']
    pet: Union[bool, 'PetArgsFromUserRecursive3']


class WishlistIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']
    product: Union[bool, 'ProductArgsFromUserRecursive4']
    pet: Union[bool, 'PetArgsFromUserRecursive4']


class WishlistIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class WishlistArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'WishlistIncludeFromWishlistRecursive1'


class WishlistArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'WishlistIncludeFromWishlistRecursive2'


class WishlistArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'WishlistIncludeFromWishlistRecursive3'


class WishlistArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'WishlistIncludeFromWishlistRecursive4'


class WishlistArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyWishlistArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive1'


class FindManyWishlistArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive2'


class FindManyWishlistArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive3'


class FindManyWishlistArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive4'


class FindManyWishlistArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    
    

class OrderIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromUserRecursive1']


class OrderIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromUserRecursive2']


class OrderIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromUserRecursive3']


class OrderIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromUserRecursive4']


class OrderIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class OrderArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'OrderIncludeFromOrderRecursive1'


class OrderArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'OrderIncludeFromOrderRecursive2'


class OrderArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'OrderIncludeFromOrderRecursive3'


class OrderArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'OrderIncludeFromOrderRecursive4'


class OrderArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyOrderArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive1'


class FindManyOrderArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive2'


class FindManyOrderArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive3'


class FindManyOrderArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive4'


class FindManyOrderArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    
    

class OrderItemIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    order: Union[bool, 'OrderArgsFromUserRecursive1']
    product: Union[bool, 'ProductArgsFromUserRecursive1']
    pet: Union[bool, 'PetArgsFromUserRecursive1']


class OrderItemIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    order: Union[bool, 'OrderArgsFromUserRecursive2']
    product: Union[bool, 'ProductArgsFromUserRecursive2']
    pet: Union[bool, 'PetArgsFromUserRecursive2']


class OrderItemIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    order: Union[bool, 'OrderArgsFromUserRecursive3']
    product: Union[bool, 'ProductArgsFromUserRecursive3']
    pet: Union[bool, 'PetArgsFromUserRecursive3']


class OrderItemIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    order: Union[bool, 'OrderArgsFromUserRecursive4']
    product: Union[bool, 'ProductArgsFromUserRecursive4']
    pet: Union[bool, 'PetArgsFromUserRecursive4']


class OrderItemIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class OrderItemArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class OrderItemArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class OrderItemArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class OrderItemArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class OrderItemArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyOrderItemArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class FindManyOrderItemArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class FindManyOrderItemArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class FindManyOrderItemArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class FindManyOrderItemArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    


FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


    

class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    firebaseUid: Union[_str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    address: Union[None, _str, 'types.StringFilter']
    city: Union[None, _str, 'types.StringFilter']
    state: Union[None, _str, 'types.StringFilter']
    zipCode: Union[None, _str, 'types.StringFilter']
    country: Union[None, _str, 'types.StringFilter']
    profileImage: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orders: 'OrderListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive1']
    OR: List['UserWhereInputRecursive1']
    NOT: List['UserWhereInputRecursive1']


class UserWhereInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    firebaseUid: Union[_str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    address: Union[None, _str, 'types.StringFilter']
    city: Union[None, _str, 'types.StringFilter']
    state: Union[None, _str, 'types.StringFilter']
    zipCode: Union[None, _str, 'types.StringFilter']
    country: Union[None, _str, 'types.StringFilter']
    profileImage: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orders: 'OrderListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive2']
    OR: List['UserWhereInputRecursive2']
    NOT: List['UserWhereInputRecursive2']


class UserWhereInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    firebaseUid: Union[_str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    address: Union[None, _str, 'types.StringFilter']
    city: Union[None, _str, 'types.StringFilter']
    state: Union[None, _str, 'types.StringFilter']
    zipCode: Union[None, _str, 'types.StringFilter']
    country: Union[None, _str, 'types.StringFilter']
    profileImage: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orders: 'OrderListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive3', List['UserWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive3']
    OR: List['UserWhereInputRecursive3']
    NOT: List['UserWhereInputRecursive3']


class UserWhereInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    firebaseUid: Union[_str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    address: Union[None, _str, 'types.StringFilter']
    city: Union[None, _str, 'types.StringFilter']
    state: Union[None, _str, 'types.StringFilter']
    zipCode: Union[None, _str, 'types.StringFilter']
    country: Union[None, _str, 'types.StringFilter']
    profileImage: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orders: 'OrderListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive4', List['UserWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive4']
    OR: List['UserWhereInputRecursive4']
    NOT: List['UserWhereInputRecursive4']


class UserWhereInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    firebaseUid: Union[_str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    address: Union[None, _str, 'types.StringFilter']
    city: Union[None, _str, 'types.StringFilter']
    state: Union[None, _str, 'types.StringFilter']
    zipCode: Union[None, _str, 'types.StringFilter']
    country: Union[None, _str, 'types.StringFilter']
    profileImage: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orders: 'OrderListRelationFilter'



# aggregate User types


    

class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    firebaseUid: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    address: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zipCode: Union[_str, 'types.StringWithAggregatesFilter']
    country: Union[_str, 'types.StringWithAggregatesFilter']
    profileImage: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive1']


class UserScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    firebaseUid: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    address: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zipCode: Union[_str, 'types.StringWithAggregatesFilter']
    country: Union[_str, 'types.StringWithAggregatesFilter']
    profileImage: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive2']


class UserScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    firebaseUid: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    address: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zipCode: Union[_str, 'types.StringWithAggregatesFilter']
    country: Union[_str, 'types.StringWithAggregatesFilter']
    profileImage: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive3']
    OR: List['UserScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive3']


class UserScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    firebaseUid: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    address: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zipCode: Union[_str, 'types.StringWithAggregatesFilter']
    country: Union[_str, 'types.StringWithAggregatesFilter']
    profileImage: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive4']
    OR: List['UserScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive4']


class UserScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    firebaseUid: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    address: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zipCode: Union[_str, 'types.StringWithAggregatesFilter']
    country: Union[_str, 'types.StringWithAggregatesFilter']
    profileImage: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class UserGroupByOutput(TypedDict, total=False):
    id: _str
    email: _str
    name: _str
    firebaseUid: _str
    phone: _str
    address: _str
    city: _str
    state: _str
    zipCode: _str
    country: _str
    profileImage: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _str
    email: _str
    name: _str
    firebaseUid: _str
    phone: _str
    address: _str
    city: _str
    state: _str
    zipCode: _str
    country: _str
    profileImage: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    email: bool
    name: bool
    firebaseUid: bool
    phone: bool
    address: bool
    city: bool
    state: bool
    zipCode: bool
    country: bool
    profileImage: bool
    createdAt: bool
    updatedAt: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    email: bool
    name: bool
    firebaseUid: bool
    phone: bool
    address: bool
    city: bool
    state: bool
    zipCode: bool
    country: bool
    profileImage: bool
    createdAt: bool
    updatedAt: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'name': bool,
        'firebaseUid': bool,
        'phone': bool,
        'address': bool,
        'city': bool,
        'state': bool,
        'zipCode': bool,
        'country': bool,
        'profileImage': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'name': int,
        'firebaseUid': int,
        'phone': int,
        'address': int,
        'city': int,
        'state': int,
        'zipCode': int,
        'country': int,
        'profileImage': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'email',
    'name',
    'firebaseUid',
    'phone',
    'address',
    'city',
    'state',
    'zipCode',
    'country',
    'profileImage',
    'createdAt',
    'updatedAt',
    'cartItems',
    'wishlistItems',
    'orders',
]
UserScalarFieldKeys = Literal[
    'id',
    'email',
    'name',
    'firebaseUid',
    'phone',
    'address',
    'city',
    'state',
    'zipCode',
    'country',
    'profileImage',
    'createdAt',
    'updatedAt',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'cartItems',
        'wishlistItems',
        'orders',
    ]

# Pet types

class PetOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Pet create method"""
    id: _str
    weight: Optional[_float]
    description: Optional[_str]
    images: List[_str]
    videos: List[_str]
    healthRecords: Optional[_str]
    personality: List[_str]
    breederRating: _float
    shelterName: Optional[_str]
    available: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    cartItems: 'CartItemCreateManyNestedWithoutRelationsInput'
    wishlistItems: 'WishlistCreateManyNestedWithoutRelationsInput'
    orderItems: 'OrderItemCreateManyNestedWithoutRelationsInput'


class PetCreateInput(PetOptionalCreateInput):
    """Required arguments to the Pet create method"""
    name: _str
    species: _str
    breed: _str
    age: _int
    breederName: _str
    price: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PetOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Pet create method, without relations"""
    id: _str
    weight: Optional[_float]
    description: Optional[_str]
    images: List[_str]
    videos: List[_str]
    healthRecords: Optional[_str]
    personality: List[_str]
    breederRating: _float
    shelterName: Optional[_str]
    available: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PetCreateWithoutRelationsInput(PetOptionalCreateWithoutRelationsInput):
    """Required arguments to the Pet create method, without relations"""
    name: _str
    species: _str
    breed: _str
    age: _int
    breederName: _str
    price: _float


class PetCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PetCreateWithoutRelationsInput'
    connect: 'PetWhereUniqueInput'


class PetCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PetCreateWithoutRelationsInput', List['PetCreateWithoutRelationsInput']]
    connect: Union['PetWhereUniqueInput', List['PetWhereUniqueInput']]


_PetWhereUnique_id_Input = TypedDict(
    '_PetWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PetWhereUniqueInput = _PetWhereUnique_id_Input


class PetUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    species: _str
    breed: _str
    age: Union[AtomicIntInput, _int]
    weight: Optional[Union[AtomicFloatInput, _float]]
    description: Optional[_str]
    images: 'types.StringListUpdate'
    videos: 'types.StringListUpdate'
    healthRecords: Optional[_str]
    personality: 'types.StringListUpdate'
    breederName: _str
    breederRating: Union[AtomicFloatInput, _float]
    shelterName: Optional[_str]
    price: Union[AtomicFloatInput, _float]
    available: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    cartItems: 'CartItemUpdateManyWithoutRelationsInput'
    wishlistItems: 'WishlistUpdateManyWithoutRelationsInput'
    orderItems: 'OrderItemUpdateManyWithoutRelationsInput'


class PetUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    species: _str
    breed: _str
    age: Union[AtomicIntInput, _int]
    weight: Optional[Union[AtomicFloatInput, _float]]
    description: Optional[_str]
    images: 'types.StringListUpdate'
    videos: 'types.StringListUpdate'
    healthRecords: Optional[_str]
    personality: 'types.StringListUpdate'
    breederName: _str
    breederRating: Union[AtomicFloatInput, _float]
    shelterName: Optional[_str]
    price: Union[AtomicFloatInput, _float]
    available: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PetUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PetCreateWithoutRelationsInput']
    connect: List['PetWhereUniqueInput']
    set: List['PetWhereUniqueInput']
    disconnect: List['PetWhereUniqueInput']
    delete: List['PetWhereUniqueInput']

    # TODO
    # update: List['PetUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PetUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PetScalarWhereInput']
    # upsert: List['PetUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['PetCreateOrConnectWithoutRelationsInput']


class PetUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PetCreateWithoutRelationsInput'
    connect: 'PetWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PetUpdateInput'
    # upsert: 'PetUpsertWithoutRelationsInput'
    # connectOrCreate: 'PetCreateOrConnectWithoutRelationsInput'


class PetUpsertInput(TypedDict):
    create: 'PetCreateInput'
    update: 'PetUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Pet_id_OrderByInput = TypedDict(
    '_Pet_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Pet_name_OrderByInput = TypedDict(
    '_Pet_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Pet_species_OrderByInput = TypedDict(
    '_Pet_species_OrderByInput',
    {
        'species': 'SortOrder',
    },
    total=True
)

_Pet_breed_OrderByInput = TypedDict(
    '_Pet_breed_OrderByInput',
    {
        'breed': 'SortOrder',
    },
    total=True
)

_Pet_age_OrderByInput = TypedDict(
    '_Pet_age_OrderByInput',
    {
        'age': 'SortOrder',
    },
    total=True
)

_Pet_weight_OrderByInput = TypedDict(
    '_Pet_weight_OrderByInput',
    {
        'weight': 'SortOrder',
    },
    total=True
)

_Pet_description_OrderByInput = TypedDict(
    '_Pet_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Pet_images_OrderByInput = TypedDict(
    '_Pet_images_OrderByInput',
    {
        'images': 'SortOrder',
    },
    total=True
)

_Pet_videos_OrderByInput = TypedDict(
    '_Pet_videos_OrderByInput',
    {
        'videos': 'SortOrder',
    },
    total=True
)

_Pet_healthRecords_OrderByInput = TypedDict(
    '_Pet_healthRecords_OrderByInput',
    {
        'healthRecords': 'SortOrder',
    },
    total=True
)

_Pet_personality_OrderByInput = TypedDict(
    '_Pet_personality_OrderByInput',
    {
        'personality': 'SortOrder',
    },
    total=True
)

_Pet_breederName_OrderByInput = TypedDict(
    '_Pet_breederName_OrderByInput',
    {
        'breederName': 'SortOrder',
    },
    total=True
)

_Pet_breederRating_OrderByInput = TypedDict(
    '_Pet_breederRating_OrderByInput',
    {
        'breederRating': 'SortOrder',
    },
    total=True
)

_Pet_shelterName_OrderByInput = TypedDict(
    '_Pet_shelterName_OrderByInput',
    {
        'shelterName': 'SortOrder',
    },
    total=True
)

_Pet_price_OrderByInput = TypedDict(
    '_Pet_price_OrderByInput',
    {
        'price': 'SortOrder',
    },
    total=True
)

_Pet_available_OrderByInput = TypedDict(
    '_Pet_available_OrderByInput',
    {
        'available': 'SortOrder',
    },
    total=True
)

_Pet_createdAt_OrderByInput = TypedDict(
    '_Pet_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Pet_updatedAt_OrderByInput = TypedDict(
    '_Pet_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

PetOrderByInput = Union[
    '_Pet_id_OrderByInput',
    '_Pet_name_OrderByInput',
    '_Pet_species_OrderByInput',
    '_Pet_breed_OrderByInput',
    '_Pet_age_OrderByInput',
    '_Pet_weight_OrderByInput',
    '_Pet_description_OrderByInput',
    '_Pet_images_OrderByInput',
    '_Pet_videos_OrderByInput',
    '_Pet_healthRecords_OrderByInput',
    '_Pet_personality_OrderByInput',
    '_Pet_breederName_OrderByInput',
    '_Pet_breederRating_OrderByInput',
    '_Pet_shelterName_OrderByInput',
    '_Pet_price_OrderByInput',
    '_Pet_available_OrderByInput',
    '_Pet_createdAt_OrderByInput',
    '_Pet_updatedAt_OrderByInput',
]



# recursive Pet types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

PetRelationFilter = TypedDict(
    'PetRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class PetListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class PetInclude(TypedDict, total=False):
    """Pet relational arguments"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPet']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPet']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPet']


    

class UserIncludeFromPet(TypedDict, total=False):
    """Relational arguments for Pet"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPetRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPetRecursive1']
    orders: Union[bool, 'FindManyOrderArgsFromPetRecursive1']


class UserIncludeFromPetRecursive1(TypedDict, total=False):
    """Relational arguments for Pet"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPetRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPetRecursive2']
    orders: Union[bool, 'FindManyOrderArgsFromPetRecursive2']


class UserIncludeFromPetRecursive2(TypedDict, total=False):
    """Relational arguments for Pet"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPetRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPetRecursive3']
    orders: Union[bool, 'FindManyOrderArgsFromPetRecursive3']


class UserIncludeFromPetRecursive3(TypedDict, total=False):
    """Relational arguments for Pet"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPetRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPetRecursive4']
    orders: Union[bool, 'FindManyOrderArgsFromPetRecursive4']


class UserIncludeFromPetRecursive4(TypedDict, total=False):
    """Relational arguments for Pet"""

    

class UserArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    
    

class FindManyUserArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class PetIncludeFromPet(TypedDict, total=False):
    """Relational arguments for Pet"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPetRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPetRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPetRecursive1']


class PetIncludeFromPetRecursive1(TypedDict, total=False):
    """Relational arguments for Pet"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPetRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPetRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPetRecursive2']


class PetIncludeFromPetRecursive2(TypedDict, total=False):
    """Relational arguments for Pet"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPetRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPetRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPetRecursive3']


class PetIncludeFromPetRecursive3(TypedDict, total=False):
    """Relational arguments for Pet"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPetRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPetRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPetRecursive4']


class PetIncludeFromPetRecursive4(TypedDict, total=False):
    """Relational arguments for Pet"""

    

class PetArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'PetIncludeFromPetRecursive1'


class PetArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'PetIncludeFromPetRecursive2'


class PetArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'PetIncludeFromPetRecursive3'


class PetArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'PetIncludeFromPetRecursive4'


class PetArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    
    

class FindManyPetArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive1'


class FindManyPetArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive2'


class FindManyPetArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive3'


class FindManyPetArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive4'


class FindManyPetArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    
    

class ProductIncludeFromPet(TypedDict, total=False):
    """Relational arguments for Pet"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPetRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPetRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPetRecursive1']


class ProductIncludeFromPetRecursive1(TypedDict, total=False):
    """Relational arguments for Pet"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPetRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPetRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPetRecursive2']


class ProductIncludeFromPetRecursive2(TypedDict, total=False):
    """Relational arguments for Pet"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPetRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPetRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPetRecursive3']


class ProductIncludeFromPetRecursive3(TypedDict, total=False):
    """Relational arguments for Pet"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromPetRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromPetRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPetRecursive4']


class ProductIncludeFromPetRecursive4(TypedDict, total=False):
    """Relational arguments for Pet"""

    

class ProductArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'ProductIncludeFromProductRecursive1'


class ProductArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'ProductIncludeFromProductRecursive2'


class ProductArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'ProductIncludeFromProductRecursive3'


class ProductArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'ProductIncludeFromProductRecursive4'


class ProductArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    
    

class FindManyProductArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive1'


class FindManyProductArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive2'


class FindManyProductArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive3'


class FindManyProductArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive4'


class FindManyProductArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    
    

class CartItemIncludeFromPet(TypedDict, total=False):
    """Relational arguments for Pet"""
    user: Union[bool, 'UserArgsFromPetRecursive1']
    product: Union[bool, 'ProductArgsFromPetRecursive1']
    pet: Union[bool, 'PetArgsFromPetRecursive1']


class CartItemIncludeFromPetRecursive1(TypedDict, total=False):
    """Relational arguments for Pet"""
    user: Union[bool, 'UserArgsFromPetRecursive2']
    product: Union[bool, 'ProductArgsFromPetRecursive2']
    pet: Union[bool, 'PetArgsFromPetRecursive2']


class CartItemIncludeFromPetRecursive2(TypedDict, total=False):
    """Relational arguments for Pet"""
    user: Union[bool, 'UserArgsFromPetRecursive3']
    product: Union[bool, 'ProductArgsFromPetRecursive3']
    pet: Union[bool, 'PetArgsFromPetRecursive3']


class CartItemIncludeFromPetRecursive3(TypedDict, total=False):
    """Relational arguments for Pet"""
    user: Union[bool, 'UserArgsFromPetRecursive4']
    product: Union[bool, 'ProductArgsFromPetRecursive4']
    pet: Union[bool, 'PetArgsFromPetRecursive4']


class CartItemIncludeFromPetRecursive4(TypedDict, total=False):
    """Relational arguments for Pet"""

    

class CartItemArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'CartItemIncludeFromCartItemRecursive1'


class CartItemArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'CartItemIncludeFromCartItemRecursive2'


class CartItemArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'CartItemIncludeFromCartItemRecursive3'


class CartItemArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'CartItemIncludeFromCartItemRecursive4'


class CartItemArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    
    

class FindManyCartItemArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive1'


class FindManyCartItemArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive2'


class FindManyCartItemArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive3'


class FindManyCartItemArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive4'


class FindManyCartItemArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    
    

class WishlistIncludeFromPet(TypedDict, total=False):
    """Relational arguments for Pet"""
    user: Union[bool, 'UserArgsFromPetRecursive1']
    product: Union[bool, 'ProductArgsFromPetRecursive1']
    pet: Union[bool, 'PetArgsFromPetRecursive1']


class WishlistIncludeFromPetRecursive1(TypedDict, total=False):
    """Relational arguments for Pet"""
    user: Union[bool, 'UserArgsFromPetRecursive2']
    product: Union[bool, 'ProductArgsFromPetRecursive2']
    pet: Union[bool, 'PetArgsFromPetRecursive2']


class WishlistIncludeFromPetRecursive2(TypedDict, total=False):
    """Relational arguments for Pet"""
    user: Union[bool, 'UserArgsFromPetRecursive3']
    product: Union[bool, 'ProductArgsFromPetRecursive3']
    pet: Union[bool, 'PetArgsFromPetRecursive3']


class WishlistIncludeFromPetRecursive3(TypedDict, total=False):
    """Relational arguments for Pet"""
    user: Union[bool, 'UserArgsFromPetRecursive4']
    product: Union[bool, 'ProductArgsFromPetRecursive4']
    pet: Union[bool, 'PetArgsFromPetRecursive4']


class WishlistIncludeFromPetRecursive4(TypedDict, total=False):
    """Relational arguments for Pet"""

    

class WishlistArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'WishlistIncludeFromWishlistRecursive1'


class WishlistArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'WishlistIncludeFromWishlistRecursive2'


class WishlistArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'WishlistIncludeFromWishlistRecursive3'


class WishlistArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'WishlistIncludeFromWishlistRecursive4'


class WishlistArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    
    

class FindManyWishlistArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive1'


class FindManyWishlistArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive2'


class FindManyWishlistArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive3'


class FindManyWishlistArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive4'


class FindManyWishlistArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    
    

class OrderIncludeFromPet(TypedDict, total=False):
    """Relational arguments for Pet"""
    user: Union[bool, 'UserArgsFromPetRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPetRecursive1']


class OrderIncludeFromPetRecursive1(TypedDict, total=False):
    """Relational arguments for Pet"""
    user: Union[bool, 'UserArgsFromPetRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPetRecursive2']


class OrderIncludeFromPetRecursive2(TypedDict, total=False):
    """Relational arguments for Pet"""
    user: Union[bool, 'UserArgsFromPetRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPetRecursive3']


class OrderIncludeFromPetRecursive3(TypedDict, total=False):
    """Relational arguments for Pet"""
    user: Union[bool, 'UserArgsFromPetRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPetRecursive4']


class OrderIncludeFromPetRecursive4(TypedDict, total=False):
    """Relational arguments for Pet"""

    

class OrderArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'OrderIncludeFromOrderRecursive1'


class OrderArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'OrderIncludeFromOrderRecursive2'


class OrderArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'OrderIncludeFromOrderRecursive3'


class OrderArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'OrderIncludeFromOrderRecursive4'


class OrderArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    
    

class FindManyOrderArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive1'


class FindManyOrderArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive2'


class FindManyOrderArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive3'


class FindManyOrderArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive4'


class FindManyOrderArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    
    

class OrderItemIncludeFromPet(TypedDict, total=False):
    """Relational arguments for Pet"""
    order: Union[bool, 'OrderArgsFromPetRecursive1']
    product: Union[bool, 'ProductArgsFromPetRecursive1']
    pet: Union[bool, 'PetArgsFromPetRecursive1']


class OrderItemIncludeFromPetRecursive1(TypedDict, total=False):
    """Relational arguments for Pet"""
    order: Union[bool, 'OrderArgsFromPetRecursive2']
    product: Union[bool, 'ProductArgsFromPetRecursive2']
    pet: Union[bool, 'PetArgsFromPetRecursive2']


class OrderItemIncludeFromPetRecursive2(TypedDict, total=False):
    """Relational arguments for Pet"""
    order: Union[bool, 'OrderArgsFromPetRecursive3']
    product: Union[bool, 'ProductArgsFromPetRecursive3']
    pet: Union[bool, 'PetArgsFromPetRecursive3']


class OrderItemIncludeFromPetRecursive3(TypedDict, total=False):
    """Relational arguments for Pet"""
    order: Union[bool, 'OrderArgsFromPetRecursive4']
    product: Union[bool, 'ProductArgsFromPetRecursive4']
    pet: Union[bool, 'PetArgsFromPetRecursive4']


class OrderItemIncludeFromPetRecursive4(TypedDict, total=False):
    """Relational arguments for Pet"""

    

class OrderItemArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class OrderItemArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class OrderItemArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class OrderItemArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class OrderItemArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    
    

class FindManyOrderItemArgsFromPet(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class FindManyOrderItemArgsFromPetRecursive1(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class FindManyOrderItemArgsFromPetRecursive2(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class FindManyOrderItemArgsFromPetRecursive3(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class FindManyOrderItemArgsFromPetRecursive4(TypedDict, total=False):
    """Arguments for Pet"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    


FindManyPetArgs = FindManyPetArgsFromPet
FindFirstPetArgs = FindManyPetArgsFromPet


    

class PetWhereInput(TypedDict, total=False):
    """Pet arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    species: Union[_str, 'types.StringFilter']
    breed: Union[_str, 'types.StringFilter']
    age: Union[_int, 'types.IntFilter']
    weight: Union[None, _float, 'types.FloatFilter']
    description: Union[None, _str, 'types.StringFilter']
    images: 'types.StringListFilter'
    videos: 'types.StringListFilter'
    healthRecords: Union[None, _str, 'types.StringFilter']
    personality: 'types.StringListFilter'
    breederName: Union[_str, 'types.StringFilter']
    breederRating: Union[_float, 'types.FloatFilter']
    shelterName: Union[None, _str, 'types.StringFilter']
    price: Union[_float, 'types.FloatFilter']
    available: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orderItems: 'OrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['PetWhereInputRecursive1', List['PetWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['PetWhereInputRecursive1']
    OR: List['PetWhereInputRecursive1']
    NOT: List['PetWhereInputRecursive1']


class PetWhereInputRecursive1(TypedDict, total=False):
    """Pet arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    species: Union[_str, 'types.StringFilter']
    breed: Union[_str, 'types.StringFilter']
    age: Union[_int, 'types.IntFilter']
    weight: Union[None, _float, 'types.FloatFilter']
    description: Union[None, _str, 'types.StringFilter']
    images: 'types.StringListFilter'
    videos: 'types.StringListFilter'
    healthRecords: Union[None, _str, 'types.StringFilter']
    personality: 'types.StringListFilter'
    breederName: Union[_str, 'types.StringFilter']
    breederRating: Union[_float, 'types.FloatFilter']
    shelterName: Union[None, _str, 'types.StringFilter']
    price: Union[_float, 'types.FloatFilter']
    available: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orderItems: 'OrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['PetWhereInputRecursive2', List['PetWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['PetWhereInputRecursive2']
    OR: List['PetWhereInputRecursive2']
    NOT: List['PetWhereInputRecursive2']


class PetWhereInputRecursive2(TypedDict, total=False):
    """Pet arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    species: Union[_str, 'types.StringFilter']
    breed: Union[_str, 'types.StringFilter']
    age: Union[_int, 'types.IntFilter']
    weight: Union[None, _float, 'types.FloatFilter']
    description: Union[None, _str, 'types.StringFilter']
    images: 'types.StringListFilter'
    videos: 'types.StringListFilter'
    healthRecords: Union[None, _str, 'types.StringFilter']
    personality: 'types.StringListFilter'
    breederName: Union[_str, 'types.StringFilter']
    breederRating: Union[_float, 'types.FloatFilter']
    shelterName: Union[None, _str, 'types.StringFilter']
    price: Union[_float, 'types.FloatFilter']
    available: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orderItems: 'OrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['PetWhereInputRecursive3', List['PetWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['PetWhereInputRecursive3']
    OR: List['PetWhereInputRecursive3']
    NOT: List['PetWhereInputRecursive3']


class PetWhereInputRecursive3(TypedDict, total=False):
    """Pet arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    species: Union[_str, 'types.StringFilter']
    breed: Union[_str, 'types.StringFilter']
    age: Union[_int, 'types.IntFilter']
    weight: Union[None, _float, 'types.FloatFilter']
    description: Union[None, _str, 'types.StringFilter']
    images: 'types.StringListFilter'
    videos: 'types.StringListFilter'
    healthRecords: Union[None, _str, 'types.StringFilter']
    personality: 'types.StringListFilter'
    breederName: Union[_str, 'types.StringFilter']
    breederRating: Union[_float, 'types.FloatFilter']
    shelterName: Union[None, _str, 'types.StringFilter']
    price: Union[_float, 'types.FloatFilter']
    available: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orderItems: 'OrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['PetWhereInputRecursive4', List['PetWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['PetWhereInputRecursive4']
    OR: List['PetWhereInputRecursive4']
    NOT: List['PetWhereInputRecursive4']


class PetWhereInputRecursive4(TypedDict, total=False):
    """Pet arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    species: Union[_str, 'types.StringFilter']
    breed: Union[_str, 'types.StringFilter']
    age: Union[_int, 'types.IntFilter']
    weight: Union[None, _float, 'types.FloatFilter']
    description: Union[None, _str, 'types.StringFilter']
    images: 'types.StringListFilter'
    videos: 'types.StringListFilter'
    healthRecords: Union[None, _str, 'types.StringFilter']
    personality: 'types.StringListFilter'
    breederName: Union[_str, 'types.StringFilter']
    breederRating: Union[_float, 'types.FloatFilter']
    shelterName: Union[None, _str, 'types.StringFilter']
    price: Union[_float, 'types.FloatFilter']
    available: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orderItems: 'OrderItemListRelationFilter'



# aggregate Pet types


    

class PetScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Pet arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    species: Union[_str, 'types.StringWithAggregatesFilter']
    breed: Union[_str, 'types.StringWithAggregatesFilter']
    age: Union[_int, 'types.IntWithAggregatesFilter']
    weight: Union[_float, 'types.FloatWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    images: Union[_str, 'types.StringWithAggregatesFilter']
    videos: Union[_str, 'types.StringWithAggregatesFilter']
    healthRecords: Union[_str, 'types.StringWithAggregatesFilter']
    personality: Union[_str, 'types.StringWithAggregatesFilter']
    breederName: Union[_str, 'types.StringWithAggregatesFilter']
    breederRating: Union[_float, 'types.FloatWithAggregatesFilter']
    shelterName: Union[_str, 'types.StringWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    available: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PetScalarWhereWithAggregatesInputRecursive1']
    OR: List['PetScalarWhereWithAggregatesInputRecursive1']
    NOT: List['PetScalarWhereWithAggregatesInputRecursive1']


class PetScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Pet arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    species: Union[_str, 'types.StringWithAggregatesFilter']
    breed: Union[_str, 'types.StringWithAggregatesFilter']
    age: Union[_int, 'types.IntWithAggregatesFilter']
    weight: Union[_float, 'types.FloatWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    images: Union[_str, 'types.StringWithAggregatesFilter']
    videos: Union[_str, 'types.StringWithAggregatesFilter']
    healthRecords: Union[_str, 'types.StringWithAggregatesFilter']
    personality: Union[_str, 'types.StringWithAggregatesFilter']
    breederName: Union[_str, 'types.StringWithAggregatesFilter']
    breederRating: Union[_float, 'types.FloatWithAggregatesFilter']
    shelterName: Union[_str, 'types.StringWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    available: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PetScalarWhereWithAggregatesInputRecursive2']
    OR: List['PetScalarWhereWithAggregatesInputRecursive2']
    NOT: List['PetScalarWhereWithAggregatesInputRecursive2']


class PetScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Pet arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    species: Union[_str, 'types.StringWithAggregatesFilter']
    breed: Union[_str, 'types.StringWithAggregatesFilter']
    age: Union[_int, 'types.IntWithAggregatesFilter']
    weight: Union[_float, 'types.FloatWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    images: Union[_str, 'types.StringWithAggregatesFilter']
    videos: Union[_str, 'types.StringWithAggregatesFilter']
    healthRecords: Union[_str, 'types.StringWithAggregatesFilter']
    personality: Union[_str, 'types.StringWithAggregatesFilter']
    breederName: Union[_str, 'types.StringWithAggregatesFilter']
    breederRating: Union[_float, 'types.FloatWithAggregatesFilter']
    shelterName: Union[_str, 'types.StringWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    available: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PetScalarWhereWithAggregatesInputRecursive3']
    OR: List['PetScalarWhereWithAggregatesInputRecursive3']
    NOT: List['PetScalarWhereWithAggregatesInputRecursive3']


class PetScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Pet arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    species: Union[_str, 'types.StringWithAggregatesFilter']
    breed: Union[_str, 'types.StringWithAggregatesFilter']
    age: Union[_int, 'types.IntWithAggregatesFilter']
    weight: Union[_float, 'types.FloatWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    images: Union[_str, 'types.StringWithAggregatesFilter']
    videos: Union[_str, 'types.StringWithAggregatesFilter']
    healthRecords: Union[_str, 'types.StringWithAggregatesFilter']
    personality: Union[_str, 'types.StringWithAggregatesFilter']
    breederName: Union[_str, 'types.StringWithAggregatesFilter']
    breederRating: Union[_float, 'types.FloatWithAggregatesFilter']
    shelterName: Union[_str, 'types.StringWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    available: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PetScalarWhereWithAggregatesInputRecursive4']
    OR: List['PetScalarWhereWithAggregatesInputRecursive4']
    NOT: List['PetScalarWhereWithAggregatesInputRecursive4']


class PetScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Pet arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    species: Union[_str, 'types.StringWithAggregatesFilter']
    breed: Union[_str, 'types.StringWithAggregatesFilter']
    age: Union[_int, 'types.IntWithAggregatesFilter']
    weight: Union[_float, 'types.FloatWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    images: Union[_str, 'types.StringWithAggregatesFilter']
    videos: Union[_str, 'types.StringWithAggregatesFilter']
    healthRecords: Union[_str, 'types.StringWithAggregatesFilter']
    personality: Union[_str, 'types.StringWithAggregatesFilter']
    breederName: Union[_str, 'types.StringWithAggregatesFilter']
    breederRating: Union[_float, 'types.FloatWithAggregatesFilter']
    shelterName: Union[_str, 'types.StringWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    available: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class PetGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    species: _str
    breed: _str
    age: _int
    weight: _float
    description: _str
    images: List[_str]
    videos: List[_str]
    healthRecords: _str
    personality: List[_str]
    breederName: _str
    breederRating: _float
    shelterName: _str
    price: _float
    available: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PetSumAggregateOutput'
    _avg: 'PetAvgAggregateOutput'
    _min: 'PetMinAggregateOutput'
    _max: 'PetMaxAggregateOutput'
    _count: 'PetCountAggregateOutput'


class PetAvgAggregateOutput(TypedDict, total=False):
    """Pet output for aggregating averages"""
    age: float
    weight: float
    breederRating: float
    price: float


class PetSumAggregateOutput(TypedDict, total=False):
    """Pet output for aggregating sums"""
    age: _int
    weight: _float
    breederRating: _float
    price: _float


class PetScalarAggregateOutput(TypedDict, total=False):
    """Pet output including scalar fields"""
    id: _str
    name: _str
    species: _str
    breed: _str
    age: _int
    weight: _float
    description: _str
    images: List[_str]
    videos: List[_str]
    healthRecords: _str
    personality: List[_str]
    breederName: _str
    breederRating: _float
    shelterName: _str
    price: _float
    available: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PetMinAggregateOutput = PetScalarAggregateOutput
PetMaxAggregateOutput = PetScalarAggregateOutput


class PetMaxAggregateInput(TypedDict, total=False):
    """Pet input for aggregating by max"""
    id: bool
    name: bool
    species: bool
    breed: bool
    age: bool
    weight: bool
    description: bool
    images: bool
    videos: bool
    healthRecords: bool
    personality: bool
    breederName: bool
    breederRating: bool
    shelterName: bool
    price: bool
    available: bool
    createdAt: bool
    updatedAt: bool


class PetMinAggregateInput(TypedDict, total=False):
    """Pet input for aggregating by min"""
    id: bool
    name: bool
    species: bool
    breed: bool
    age: bool
    weight: bool
    description: bool
    images: bool
    videos: bool
    healthRecords: bool
    personality: bool
    breederName: bool
    breederRating: bool
    shelterName: bool
    price: bool
    available: bool
    createdAt: bool
    updatedAt: bool


class PetNumberAggregateInput(TypedDict, total=False):
    """Pet input for aggregating numbers"""
    age: bool
    weight: bool
    breederRating: bool
    price: bool


PetAvgAggregateInput = PetNumberAggregateInput
PetSumAggregateInput = PetNumberAggregateInput


PetCountAggregateInput = TypedDict(
    'PetCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'species': bool,
        'breed': bool,
        'age': bool,
        'weight': bool,
        'description': bool,
        'images': bool,
        'videos': bool,
        'healthRecords': bool,
        'personality': bool,
        'breederName': bool,
        'breederRating': bool,
        'shelterName': bool,
        'price': bool,
        'available': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PetCountAggregateOutput = TypedDict(
    'PetCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'species': int,
        'breed': int,
        'age': int,
        'weight': int,
        'description': int,
        'images': int,
        'videos': int,
        'healthRecords': int,
        'personality': int,
        'breederName': int,
        'breederRating': int,
        'shelterName': int,
        'price': int,
        'available': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PetKeys = Literal[
    'id',
    'name',
    'species',
    'breed',
    'age',
    'weight',
    'description',
    'images',
    'videos',
    'healthRecords',
    'personality',
    'breederName',
    'breederRating',
    'shelterName',
    'price',
    'available',
    'createdAt',
    'updatedAt',
    'cartItems',
    'wishlistItems',
    'orderItems',
]
PetScalarFieldKeys = Literal[
    'id',
    'name',
    'species',
    'breed',
    'age',
    'weight',
    'description',
    'images',
    'videos',
    'healthRecords',
    'personality',
    'breederName',
    'breederRating',
    'shelterName',
    'price',
    'available',
    'createdAt',
    'updatedAt',
]
PetScalarFieldKeysT = TypeVar('PetScalarFieldKeysT', bound=PetScalarFieldKeys)

PetRelationalFieldKeys = Literal[
        'cartItems',
        'wishlistItems',
        'orderItems',
    ]

# Product types

class ProductOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Product create method"""
    id: _str
    description: Optional[_str]
    petType: Optional[_str]
    brand: Optional[_str]
    images: List[_str]
    stock: _int
    filters: List[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    cartItems: 'CartItemCreateManyNestedWithoutRelationsInput'
    wishlistItems: 'WishlistCreateManyNestedWithoutRelationsInput'
    orderItems: 'OrderItemCreateManyNestedWithoutRelationsInput'


class ProductCreateInput(ProductOptionalCreateInput):
    """Required arguments to the Product create method"""
    name: _str
    category: _str
    price: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ProductOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Product create method, without relations"""
    id: _str
    description: Optional[_str]
    petType: Optional[_str]
    brand: Optional[_str]
    images: List[_str]
    stock: _int
    filters: List[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProductCreateWithoutRelationsInput(ProductOptionalCreateWithoutRelationsInput):
    """Required arguments to the Product create method, without relations"""
    name: _str
    category: _str
    price: _float


class ProductCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ProductCreateWithoutRelationsInput'
    connect: 'ProductWhereUniqueInput'


class ProductCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ProductCreateWithoutRelationsInput', List['ProductCreateWithoutRelationsInput']]
    connect: Union['ProductWhereUniqueInput', List['ProductWhereUniqueInput']]


_ProductWhereUnique_id_Input = TypedDict(
    '_ProductWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ProductWhereUniqueInput = _ProductWhereUnique_id_Input


class ProductUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    description: Optional[_str]
    category: _str
    petType: Optional[_str]
    brand: Optional[_str]
    price: Union[AtomicFloatInput, _float]
    images: 'types.StringListUpdate'
    stock: Union[AtomicIntInput, _int]
    filters: 'types.StringListUpdate'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    cartItems: 'CartItemUpdateManyWithoutRelationsInput'
    wishlistItems: 'WishlistUpdateManyWithoutRelationsInput'
    orderItems: 'OrderItemUpdateManyWithoutRelationsInput'


class ProductUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    description: Optional[_str]
    category: _str
    petType: Optional[_str]
    brand: Optional[_str]
    price: Union[AtomicFloatInput, _float]
    images: 'types.StringListUpdate'
    stock: Union[AtomicIntInput, _int]
    filters: 'types.StringListUpdate'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProductUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ProductCreateWithoutRelationsInput']
    connect: List['ProductWhereUniqueInput']
    set: List['ProductWhereUniqueInput']
    disconnect: List['ProductWhereUniqueInput']
    delete: List['ProductWhereUniqueInput']

    # TODO
    # update: List['ProductUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ProductUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ProductScalarWhereInput']
    # upsert: List['ProductUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['ProductCreateOrConnectWithoutRelationsInput']


class ProductUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ProductCreateWithoutRelationsInput'
    connect: 'ProductWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ProductUpdateInput'
    # upsert: 'ProductUpsertWithoutRelationsInput'
    # connectOrCreate: 'ProductCreateOrConnectWithoutRelationsInput'


class ProductUpsertInput(TypedDict):
    create: 'ProductCreateInput'
    update: 'ProductUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Product_id_OrderByInput = TypedDict(
    '_Product_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Product_name_OrderByInput = TypedDict(
    '_Product_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Product_description_OrderByInput = TypedDict(
    '_Product_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Product_category_OrderByInput = TypedDict(
    '_Product_category_OrderByInput',
    {
        'category': 'SortOrder',
    },
    total=True
)

_Product_petType_OrderByInput = TypedDict(
    '_Product_petType_OrderByInput',
    {
        'petType': 'SortOrder',
    },
    total=True
)

_Product_brand_OrderByInput = TypedDict(
    '_Product_brand_OrderByInput',
    {
        'brand': 'SortOrder',
    },
    total=True
)

_Product_price_OrderByInput = TypedDict(
    '_Product_price_OrderByInput',
    {
        'price': 'SortOrder',
    },
    total=True
)

_Product_images_OrderByInput = TypedDict(
    '_Product_images_OrderByInput',
    {
        'images': 'SortOrder',
    },
    total=True
)

_Product_stock_OrderByInput = TypedDict(
    '_Product_stock_OrderByInput',
    {
        'stock': 'SortOrder',
    },
    total=True
)

_Product_filters_OrderByInput = TypedDict(
    '_Product_filters_OrderByInput',
    {
        'filters': 'SortOrder',
    },
    total=True
)

_Product_createdAt_OrderByInput = TypedDict(
    '_Product_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Product_updatedAt_OrderByInput = TypedDict(
    '_Product_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

ProductOrderByInput = Union[
    '_Product_id_OrderByInput',
    '_Product_name_OrderByInput',
    '_Product_description_OrderByInput',
    '_Product_category_OrderByInput',
    '_Product_petType_OrderByInput',
    '_Product_brand_OrderByInput',
    '_Product_price_OrderByInput',
    '_Product_images_OrderByInput',
    '_Product_stock_OrderByInput',
    '_Product_filters_OrderByInput',
    '_Product_createdAt_OrderByInput',
    '_Product_updatedAt_OrderByInput',
]



# recursive Product types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ProductRelationFilter = TypedDict(
    'ProductRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ProductListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ProductInclude(TypedDict, total=False):
    """Product relational arguments"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProduct']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProduct']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProduct']


    

class UserIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProductRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProductRecursive1']
    orders: Union[bool, 'FindManyOrderArgsFromProductRecursive1']


class UserIncludeFromProductRecursive1(TypedDict, total=False):
    """Relational arguments for Product"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProductRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProductRecursive2']
    orders: Union[bool, 'FindManyOrderArgsFromProductRecursive2']


class UserIncludeFromProductRecursive2(TypedDict, total=False):
    """Relational arguments for Product"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProductRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProductRecursive3']
    orders: Union[bool, 'FindManyOrderArgsFromProductRecursive3']


class UserIncludeFromProductRecursive3(TypedDict, total=False):
    """Relational arguments for Product"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProductRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProductRecursive4']
    orders: Union[bool, 'FindManyOrderArgsFromProductRecursive4']


class UserIncludeFromProductRecursive4(TypedDict, total=False):
    """Relational arguments for Product"""

    

class UserArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    
    

class FindManyUserArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class PetIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProductRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProductRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProductRecursive1']


class PetIncludeFromProductRecursive1(TypedDict, total=False):
    """Relational arguments for Product"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProductRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProductRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProductRecursive2']


class PetIncludeFromProductRecursive2(TypedDict, total=False):
    """Relational arguments for Product"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProductRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProductRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProductRecursive3']


class PetIncludeFromProductRecursive3(TypedDict, total=False):
    """Relational arguments for Product"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProductRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProductRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProductRecursive4']


class PetIncludeFromProductRecursive4(TypedDict, total=False):
    """Relational arguments for Product"""

    

class PetArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'PetIncludeFromPetRecursive1'


class PetArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    include: 'PetIncludeFromPetRecursive2'


class PetArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    include: 'PetIncludeFromPetRecursive3'


class PetArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    include: 'PetIncludeFromPetRecursive4'


class PetArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    
    

class FindManyPetArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive1'


class FindManyPetArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive2'


class FindManyPetArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive3'


class FindManyPetArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive4'


class FindManyPetArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    
    

class ProductIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProductRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProductRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProductRecursive1']


class ProductIncludeFromProductRecursive1(TypedDict, total=False):
    """Relational arguments for Product"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProductRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProductRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProductRecursive2']


class ProductIncludeFromProductRecursive2(TypedDict, total=False):
    """Relational arguments for Product"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProductRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProductRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProductRecursive3']


class ProductIncludeFromProductRecursive3(TypedDict, total=False):
    """Relational arguments for Product"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromProductRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromProductRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProductRecursive4']


class ProductIncludeFromProductRecursive4(TypedDict, total=False):
    """Relational arguments for Product"""

    

class ProductArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ProductIncludeFromProductRecursive1'


class ProductArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ProductIncludeFromProductRecursive2'


class ProductArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ProductIncludeFromProductRecursive3'


class ProductArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ProductIncludeFromProductRecursive4'


class ProductArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    
    

class FindManyProductArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive1'


class FindManyProductArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive2'


class FindManyProductArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive3'


class FindManyProductArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive4'


class FindManyProductArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    
    

class CartItemIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProductRecursive1']
    product: Union[bool, 'ProductArgsFromProductRecursive1']
    pet: Union[bool, 'PetArgsFromProductRecursive1']


class CartItemIncludeFromProductRecursive1(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProductRecursive2']
    product: Union[bool, 'ProductArgsFromProductRecursive2']
    pet: Union[bool, 'PetArgsFromProductRecursive2']


class CartItemIncludeFromProductRecursive2(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProductRecursive3']
    product: Union[bool, 'ProductArgsFromProductRecursive3']
    pet: Union[bool, 'PetArgsFromProductRecursive3']


class CartItemIncludeFromProductRecursive3(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProductRecursive4']
    product: Union[bool, 'ProductArgsFromProductRecursive4']
    pet: Union[bool, 'PetArgsFromProductRecursive4']


class CartItemIncludeFromProductRecursive4(TypedDict, total=False):
    """Relational arguments for Product"""

    

class CartItemArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'CartItemIncludeFromCartItemRecursive1'


class CartItemArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    include: 'CartItemIncludeFromCartItemRecursive2'


class CartItemArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    include: 'CartItemIncludeFromCartItemRecursive3'


class CartItemArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    include: 'CartItemIncludeFromCartItemRecursive4'


class CartItemArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    
    

class FindManyCartItemArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive1'


class FindManyCartItemArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive2'


class FindManyCartItemArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive3'


class FindManyCartItemArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive4'


class FindManyCartItemArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    
    

class WishlistIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProductRecursive1']
    product: Union[bool, 'ProductArgsFromProductRecursive1']
    pet: Union[bool, 'PetArgsFromProductRecursive1']


class WishlistIncludeFromProductRecursive1(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProductRecursive2']
    product: Union[bool, 'ProductArgsFromProductRecursive2']
    pet: Union[bool, 'PetArgsFromProductRecursive2']


class WishlistIncludeFromProductRecursive2(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProductRecursive3']
    product: Union[bool, 'ProductArgsFromProductRecursive3']
    pet: Union[bool, 'PetArgsFromProductRecursive3']


class WishlistIncludeFromProductRecursive3(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProductRecursive4']
    product: Union[bool, 'ProductArgsFromProductRecursive4']
    pet: Union[bool, 'PetArgsFromProductRecursive4']


class WishlistIncludeFromProductRecursive4(TypedDict, total=False):
    """Relational arguments for Product"""

    

class WishlistArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'WishlistIncludeFromWishlistRecursive1'


class WishlistArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    include: 'WishlistIncludeFromWishlistRecursive2'


class WishlistArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    include: 'WishlistIncludeFromWishlistRecursive3'


class WishlistArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    include: 'WishlistIncludeFromWishlistRecursive4'


class WishlistArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    
    

class FindManyWishlistArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive1'


class FindManyWishlistArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive2'


class FindManyWishlistArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive3'


class FindManyWishlistArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive4'


class FindManyWishlistArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    
    

class OrderIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProductRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProductRecursive1']


class OrderIncludeFromProductRecursive1(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProductRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProductRecursive2']


class OrderIncludeFromProductRecursive2(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProductRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProductRecursive3']


class OrderIncludeFromProductRecursive3(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProductRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromProductRecursive4']


class OrderIncludeFromProductRecursive4(TypedDict, total=False):
    """Relational arguments for Product"""

    

class OrderArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'OrderIncludeFromOrderRecursive1'


class OrderArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    include: 'OrderIncludeFromOrderRecursive2'


class OrderArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    include: 'OrderIncludeFromOrderRecursive3'


class OrderArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    include: 'OrderIncludeFromOrderRecursive4'


class OrderArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    
    

class FindManyOrderArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive1'


class FindManyOrderArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive2'


class FindManyOrderArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive3'


class FindManyOrderArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive4'


class FindManyOrderArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    
    

class OrderItemIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    order: Union[bool, 'OrderArgsFromProductRecursive1']
    product: Union[bool, 'ProductArgsFromProductRecursive1']
    pet: Union[bool, 'PetArgsFromProductRecursive1']


class OrderItemIncludeFromProductRecursive1(TypedDict, total=False):
    """Relational arguments for Product"""
    order: Union[bool, 'OrderArgsFromProductRecursive2']
    product: Union[bool, 'ProductArgsFromProductRecursive2']
    pet: Union[bool, 'PetArgsFromProductRecursive2']


class OrderItemIncludeFromProductRecursive2(TypedDict, total=False):
    """Relational arguments for Product"""
    order: Union[bool, 'OrderArgsFromProductRecursive3']
    product: Union[bool, 'ProductArgsFromProductRecursive3']
    pet: Union[bool, 'PetArgsFromProductRecursive3']


class OrderItemIncludeFromProductRecursive3(TypedDict, total=False):
    """Relational arguments for Product"""
    order: Union[bool, 'OrderArgsFromProductRecursive4']
    product: Union[bool, 'ProductArgsFromProductRecursive4']
    pet: Union[bool, 'PetArgsFromProductRecursive4']


class OrderItemIncludeFromProductRecursive4(TypedDict, total=False):
    """Relational arguments for Product"""

    

class OrderItemArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class OrderItemArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class OrderItemArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class OrderItemArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class OrderItemArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    
    

class FindManyOrderItemArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class FindManyOrderItemArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class FindManyOrderItemArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class FindManyOrderItemArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class FindManyOrderItemArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    


FindManyProductArgs = FindManyProductArgsFromProduct
FindFirstProductArgs = FindManyProductArgsFromProduct


    

class ProductWhereInput(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    category: Union[_str, 'types.StringFilter']
    petType: Union[None, _str, 'types.StringFilter']
    brand: Union[None, _str, 'types.StringFilter']
    price: Union[_float, 'types.FloatFilter']
    images: 'types.StringListFilter'
    stock: Union[_int, 'types.IntFilter']
    filters: 'types.StringListFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orderItems: 'OrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['ProductWhereInputRecursive1', List['ProductWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ProductWhereInputRecursive1']
    OR: List['ProductWhereInputRecursive1']
    NOT: List['ProductWhereInputRecursive1']


class ProductWhereInputRecursive1(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    category: Union[_str, 'types.StringFilter']
    petType: Union[None, _str, 'types.StringFilter']
    brand: Union[None, _str, 'types.StringFilter']
    price: Union[_float, 'types.FloatFilter']
    images: 'types.StringListFilter'
    stock: Union[_int, 'types.IntFilter']
    filters: 'types.StringListFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orderItems: 'OrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['ProductWhereInputRecursive2', List['ProductWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ProductWhereInputRecursive2']
    OR: List['ProductWhereInputRecursive2']
    NOT: List['ProductWhereInputRecursive2']


class ProductWhereInputRecursive2(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    category: Union[_str, 'types.StringFilter']
    petType: Union[None, _str, 'types.StringFilter']
    brand: Union[None, _str, 'types.StringFilter']
    price: Union[_float, 'types.FloatFilter']
    images: 'types.StringListFilter'
    stock: Union[_int, 'types.IntFilter']
    filters: 'types.StringListFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orderItems: 'OrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['ProductWhereInputRecursive3', List['ProductWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ProductWhereInputRecursive3']
    OR: List['ProductWhereInputRecursive3']
    NOT: List['ProductWhereInputRecursive3']


class ProductWhereInputRecursive3(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    category: Union[_str, 'types.StringFilter']
    petType: Union[None, _str, 'types.StringFilter']
    brand: Union[None, _str, 'types.StringFilter']
    price: Union[_float, 'types.FloatFilter']
    images: 'types.StringListFilter'
    stock: Union[_int, 'types.IntFilter']
    filters: 'types.StringListFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orderItems: 'OrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['ProductWhereInputRecursive4', List['ProductWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ProductWhereInputRecursive4']
    OR: List['ProductWhereInputRecursive4']
    NOT: List['ProductWhereInputRecursive4']


class ProductWhereInputRecursive4(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    category: Union[_str, 'types.StringFilter']
    petType: Union[None, _str, 'types.StringFilter']
    brand: Union[None, _str, 'types.StringFilter']
    price: Union[_float, 'types.FloatFilter']
    images: 'types.StringListFilter'
    stock: Union[_int, 'types.IntFilter']
    filters: 'types.StringListFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    cartItems: 'CartItemListRelationFilter'
    wishlistItems: 'WishlistListRelationFilter'
    orderItems: 'OrderItemListRelationFilter'



# aggregate Product types


    

class ProductScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    petType: Union[_str, 'types.StringWithAggregatesFilter']
    brand: Union[_str, 'types.StringWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    images: Union[_str, 'types.StringWithAggregatesFilter']
    stock: Union[_int, 'types.IntWithAggregatesFilter']
    filters: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProductScalarWhereWithAggregatesInputRecursive1']
    OR: List['ProductScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ProductScalarWhereWithAggregatesInputRecursive1']


class ProductScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    petType: Union[_str, 'types.StringWithAggregatesFilter']
    brand: Union[_str, 'types.StringWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    images: Union[_str, 'types.StringWithAggregatesFilter']
    stock: Union[_int, 'types.IntWithAggregatesFilter']
    filters: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProductScalarWhereWithAggregatesInputRecursive2']
    OR: List['ProductScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ProductScalarWhereWithAggregatesInputRecursive2']


class ProductScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    petType: Union[_str, 'types.StringWithAggregatesFilter']
    brand: Union[_str, 'types.StringWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    images: Union[_str, 'types.StringWithAggregatesFilter']
    stock: Union[_int, 'types.IntWithAggregatesFilter']
    filters: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProductScalarWhereWithAggregatesInputRecursive3']
    OR: List['ProductScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ProductScalarWhereWithAggregatesInputRecursive3']


class ProductScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    petType: Union[_str, 'types.StringWithAggregatesFilter']
    brand: Union[_str, 'types.StringWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    images: Union[_str, 'types.StringWithAggregatesFilter']
    stock: Union[_int, 'types.IntWithAggregatesFilter']
    filters: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProductScalarWhereWithAggregatesInputRecursive4']
    OR: List['ProductScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ProductScalarWhereWithAggregatesInputRecursive4']


class ProductScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    petType: Union[_str, 'types.StringWithAggregatesFilter']
    brand: Union[_str, 'types.StringWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    images: Union[_str, 'types.StringWithAggregatesFilter']
    stock: Union[_int, 'types.IntWithAggregatesFilter']
    filters: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class ProductGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    description: _str
    category: _str
    petType: _str
    brand: _str
    price: _float
    images: List[_str]
    stock: _int
    filters: List[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'ProductSumAggregateOutput'
    _avg: 'ProductAvgAggregateOutput'
    _min: 'ProductMinAggregateOutput'
    _max: 'ProductMaxAggregateOutput'
    _count: 'ProductCountAggregateOutput'


class ProductAvgAggregateOutput(TypedDict, total=False):
    """Product output for aggregating averages"""
    price: float
    stock: float


class ProductSumAggregateOutput(TypedDict, total=False):
    """Product output for aggregating sums"""
    price: _float
    stock: _int


class ProductScalarAggregateOutput(TypedDict, total=False):
    """Product output including scalar fields"""
    id: _str
    name: _str
    description: _str
    category: _str
    petType: _str
    brand: _str
    price: _float
    images: List[_str]
    stock: _int
    filters: List[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


ProductMinAggregateOutput = ProductScalarAggregateOutput
ProductMaxAggregateOutput = ProductScalarAggregateOutput


class ProductMaxAggregateInput(TypedDict, total=False):
    """Product input for aggregating by max"""
    id: bool
    name: bool
    description: bool
    category: bool
    petType: bool
    brand: bool
    price: bool
    images: bool
    stock: bool
    filters: bool
    createdAt: bool
    updatedAt: bool


class ProductMinAggregateInput(TypedDict, total=False):
    """Product input for aggregating by min"""
    id: bool
    name: bool
    description: bool
    category: bool
    petType: bool
    brand: bool
    price: bool
    images: bool
    stock: bool
    filters: bool
    createdAt: bool
    updatedAt: bool


class ProductNumberAggregateInput(TypedDict, total=False):
    """Product input for aggregating numbers"""
    price: bool
    stock: bool


ProductAvgAggregateInput = ProductNumberAggregateInput
ProductSumAggregateInput = ProductNumberAggregateInput


ProductCountAggregateInput = TypedDict(
    'ProductCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'description': bool,
        'category': bool,
        'petType': bool,
        'brand': bool,
        'price': bool,
        'images': bool,
        'stock': bool,
        'filters': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

ProductCountAggregateOutput = TypedDict(
    'ProductCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'description': int,
        'category': int,
        'petType': int,
        'brand': int,
        'price': int,
        'images': int,
        'stock': int,
        'filters': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


ProductKeys = Literal[
    'id',
    'name',
    'description',
    'category',
    'petType',
    'brand',
    'price',
    'images',
    'stock',
    'filters',
    'createdAt',
    'updatedAt',
    'cartItems',
    'wishlistItems',
    'orderItems',
]
ProductScalarFieldKeys = Literal[
    'id',
    'name',
    'description',
    'category',
    'petType',
    'brand',
    'price',
    'images',
    'stock',
    'filters',
    'createdAt',
    'updatedAt',
]
ProductScalarFieldKeysT = TypeVar('ProductScalarFieldKeysT', bound=ProductScalarFieldKeys)

ProductRelationalFieldKeys = Literal[
        'cartItems',
        'wishlistItems',
        'orderItems',
    ]

# CartItem types

class CartItemOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the CartItem create method"""
    id: _str
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    productId: Optional[_str]
    product: 'ProductCreateNestedWithoutRelationsInput'
    petId: Optional[_str]
    pet: 'PetCreateNestedWithoutRelationsInput'
    quantity: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CartItemCreateInput(CartItemOptionalCreateInput):
    """Required arguments to the CartItem create method"""
    price: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CartItemOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the CartItem create method, without relations"""
    id: _str
    userId: _str
    productId: Optional[_str]
    petId: Optional[_str]
    quantity: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CartItemCreateWithoutRelationsInput(CartItemOptionalCreateWithoutRelationsInput):
    """Required arguments to the CartItem create method, without relations"""
    price: _float


class CartItemCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CartItemCreateWithoutRelationsInput'
    connect: 'CartItemWhereUniqueInput'


class CartItemCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CartItemCreateWithoutRelationsInput', List['CartItemCreateWithoutRelationsInput']]
    connect: Union['CartItemWhereUniqueInput', List['CartItemWhereUniqueInput']]


_CartItemWhereUnique_id_Input = TypedDict(
    '_CartItemWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

CartItemWhereUniqueInput = _CartItemWhereUnique_id_Input


class CartItemUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    user: 'UserUpdateOneWithoutRelationsInput'
    product: 'ProductUpdateOneWithoutRelationsInput'
    pet: 'PetUpdateOneWithoutRelationsInput'
    quantity: Union[AtomicIntInput, _int]
    price: Union[AtomicFloatInput, _float]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CartItemUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    quantity: Union[AtomicIntInput, _int]
    price: Union[AtomicFloatInput, _float]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CartItemUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CartItemCreateWithoutRelationsInput']
    connect: List['CartItemWhereUniqueInput']
    set: List['CartItemWhereUniqueInput']
    disconnect: List['CartItemWhereUniqueInput']
    delete: List['CartItemWhereUniqueInput']

    # TODO
    # update: List['CartItemUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CartItemUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CartItemScalarWhereInput']
    # upsert: List['CartItemUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['CartItemCreateOrConnectWithoutRelationsInput']


class CartItemUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CartItemCreateWithoutRelationsInput'
    connect: 'CartItemWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CartItemUpdateInput'
    # upsert: 'CartItemUpsertWithoutRelationsInput'
    # connectOrCreate: 'CartItemCreateOrConnectWithoutRelationsInput'


class CartItemUpsertInput(TypedDict):
    create: 'CartItemCreateInput'
    update: 'CartItemUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_CartItem_id_OrderByInput = TypedDict(
    '_CartItem_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_CartItem_userId_OrderByInput = TypedDict(
    '_CartItem_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_CartItem_productId_OrderByInput = TypedDict(
    '_CartItem_productId_OrderByInput',
    {
        'productId': 'SortOrder',
    },
    total=True
)

_CartItem_petId_OrderByInput = TypedDict(
    '_CartItem_petId_OrderByInput',
    {
        'petId': 'SortOrder',
    },
    total=True
)

_CartItem_quantity_OrderByInput = TypedDict(
    '_CartItem_quantity_OrderByInput',
    {
        'quantity': 'SortOrder',
    },
    total=True
)

_CartItem_price_OrderByInput = TypedDict(
    '_CartItem_price_OrderByInput',
    {
        'price': 'SortOrder',
    },
    total=True
)

_CartItem_createdAt_OrderByInput = TypedDict(
    '_CartItem_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_CartItem_updatedAt_OrderByInput = TypedDict(
    '_CartItem_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

CartItemOrderByInput = Union[
    '_CartItem_id_OrderByInput',
    '_CartItem_userId_OrderByInput',
    '_CartItem_productId_OrderByInput',
    '_CartItem_petId_OrderByInput',
    '_CartItem_quantity_OrderByInput',
    '_CartItem_price_OrderByInput',
    '_CartItem_createdAt_OrderByInput',
    '_CartItem_updatedAt_OrderByInput',
]



# recursive CartItem types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CartItemRelationFilter = TypedDict(
    'CartItemRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CartItemListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CartItemInclude(TypedDict, total=False):
    """CartItem relational arguments"""
    user: Union[bool, 'UserArgsFromCartItem']
    product: Union[bool, 'ProductArgsFromCartItem']
    pet: Union[bool, 'PetArgsFromCartItem']


    

class UserIncludeFromCartItem(TypedDict, total=False):
    """Relational arguments for CartItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromCartItemRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromCartItemRecursive1']
    orders: Union[bool, 'FindManyOrderArgsFromCartItemRecursive1']


class UserIncludeFromCartItemRecursive1(TypedDict, total=False):
    """Relational arguments for CartItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromCartItemRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromCartItemRecursive2']
    orders: Union[bool, 'FindManyOrderArgsFromCartItemRecursive2']


class UserIncludeFromCartItemRecursive2(TypedDict, total=False):
    """Relational arguments for CartItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromCartItemRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromCartItemRecursive3']
    orders: Union[bool, 'FindManyOrderArgsFromCartItemRecursive3']


class UserIncludeFromCartItemRecursive3(TypedDict, total=False):
    """Relational arguments for CartItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromCartItemRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromCartItemRecursive4']
    orders: Union[bool, 'FindManyOrderArgsFromCartItemRecursive4']


class UserIncludeFromCartItemRecursive4(TypedDict, total=False):
    """Relational arguments for CartItem"""

    

class UserArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    
    

class FindManyUserArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class PetIncludeFromCartItem(TypedDict, total=False):
    """Relational arguments for CartItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromCartItemRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromCartItemRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromCartItemRecursive1']


class PetIncludeFromCartItemRecursive1(TypedDict, total=False):
    """Relational arguments for CartItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromCartItemRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromCartItemRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromCartItemRecursive2']


class PetIncludeFromCartItemRecursive2(TypedDict, total=False):
    """Relational arguments for CartItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromCartItemRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromCartItemRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromCartItemRecursive3']


class PetIncludeFromCartItemRecursive3(TypedDict, total=False):
    """Relational arguments for CartItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromCartItemRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromCartItemRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromCartItemRecursive4']


class PetIncludeFromCartItemRecursive4(TypedDict, total=False):
    """Relational arguments for CartItem"""

    

class PetArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'PetIncludeFromPetRecursive1'


class PetArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'PetIncludeFromPetRecursive2'


class PetArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'PetIncludeFromPetRecursive3'


class PetArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'PetIncludeFromPetRecursive4'


class PetArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    
    

class FindManyPetArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive1'


class FindManyPetArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive2'


class FindManyPetArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive3'


class FindManyPetArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive4'


class FindManyPetArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    
    

class ProductIncludeFromCartItem(TypedDict, total=False):
    """Relational arguments for CartItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromCartItemRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromCartItemRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromCartItemRecursive1']


class ProductIncludeFromCartItemRecursive1(TypedDict, total=False):
    """Relational arguments for CartItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromCartItemRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromCartItemRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromCartItemRecursive2']


class ProductIncludeFromCartItemRecursive2(TypedDict, total=False):
    """Relational arguments for CartItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromCartItemRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromCartItemRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromCartItemRecursive3']


class ProductIncludeFromCartItemRecursive3(TypedDict, total=False):
    """Relational arguments for CartItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromCartItemRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromCartItemRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromCartItemRecursive4']


class ProductIncludeFromCartItemRecursive4(TypedDict, total=False):
    """Relational arguments for CartItem"""

    

class ProductArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'ProductIncludeFromProductRecursive1'


class ProductArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'ProductIncludeFromProductRecursive2'


class ProductArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'ProductIncludeFromProductRecursive3'


class ProductArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'ProductIncludeFromProductRecursive4'


class ProductArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    
    

class FindManyProductArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive1'


class FindManyProductArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive2'


class FindManyProductArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive3'


class FindManyProductArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive4'


class FindManyProductArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    
    

class CartItemIncludeFromCartItem(TypedDict, total=False):
    """Relational arguments for CartItem"""
    user: Union[bool, 'UserArgsFromCartItemRecursive1']
    product: Union[bool, 'ProductArgsFromCartItemRecursive1']
    pet: Union[bool, 'PetArgsFromCartItemRecursive1']


class CartItemIncludeFromCartItemRecursive1(TypedDict, total=False):
    """Relational arguments for CartItem"""
    user: Union[bool, 'UserArgsFromCartItemRecursive2']
    product: Union[bool, 'ProductArgsFromCartItemRecursive2']
    pet: Union[bool, 'PetArgsFromCartItemRecursive2']


class CartItemIncludeFromCartItemRecursive2(TypedDict, total=False):
    """Relational arguments for CartItem"""
    user: Union[bool, 'UserArgsFromCartItemRecursive3']
    product: Union[bool, 'ProductArgsFromCartItemRecursive3']
    pet: Union[bool, 'PetArgsFromCartItemRecursive3']


class CartItemIncludeFromCartItemRecursive3(TypedDict, total=False):
    """Relational arguments for CartItem"""
    user: Union[bool, 'UserArgsFromCartItemRecursive4']
    product: Union[bool, 'ProductArgsFromCartItemRecursive4']
    pet: Union[bool, 'PetArgsFromCartItemRecursive4']


class CartItemIncludeFromCartItemRecursive4(TypedDict, total=False):
    """Relational arguments for CartItem"""

    

class CartItemArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'CartItemIncludeFromCartItemRecursive1'


class CartItemArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'CartItemIncludeFromCartItemRecursive2'


class CartItemArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'CartItemIncludeFromCartItemRecursive3'


class CartItemArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'CartItemIncludeFromCartItemRecursive4'


class CartItemArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    
    

class FindManyCartItemArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive1'


class FindManyCartItemArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive2'


class FindManyCartItemArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive3'


class FindManyCartItemArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive4'


class FindManyCartItemArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    
    

class WishlistIncludeFromCartItem(TypedDict, total=False):
    """Relational arguments for CartItem"""
    user: Union[bool, 'UserArgsFromCartItemRecursive1']
    product: Union[bool, 'ProductArgsFromCartItemRecursive1']
    pet: Union[bool, 'PetArgsFromCartItemRecursive1']


class WishlistIncludeFromCartItemRecursive1(TypedDict, total=False):
    """Relational arguments for CartItem"""
    user: Union[bool, 'UserArgsFromCartItemRecursive2']
    product: Union[bool, 'ProductArgsFromCartItemRecursive2']
    pet: Union[bool, 'PetArgsFromCartItemRecursive2']


class WishlistIncludeFromCartItemRecursive2(TypedDict, total=False):
    """Relational arguments for CartItem"""
    user: Union[bool, 'UserArgsFromCartItemRecursive3']
    product: Union[bool, 'ProductArgsFromCartItemRecursive3']
    pet: Union[bool, 'PetArgsFromCartItemRecursive3']


class WishlistIncludeFromCartItemRecursive3(TypedDict, total=False):
    """Relational arguments for CartItem"""
    user: Union[bool, 'UserArgsFromCartItemRecursive4']
    product: Union[bool, 'ProductArgsFromCartItemRecursive4']
    pet: Union[bool, 'PetArgsFromCartItemRecursive4']


class WishlistIncludeFromCartItemRecursive4(TypedDict, total=False):
    """Relational arguments for CartItem"""

    

class WishlistArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'WishlistIncludeFromWishlistRecursive1'


class WishlistArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'WishlistIncludeFromWishlistRecursive2'


class WishlistArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'WishlistIncludeFromWishlistRecursive3'


class WishlistArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'WishlistIncludeFromWishlistRecursive4'


class WishlistArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    
    

class FindManyWishlistArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive1'


class FindManyWishlistArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive2'


class FindManyWishlistArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive3'


class FindManyWishlistArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive4'


class FindManyWishlistArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    
    

class OrderIncludeFromCartItem(TypedDict, total=False):
    """Relational arguments for CartItem"""
    user: Union[bool, 'UserArgsFromCartItemRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromCartItemRecursive1']


class OrderIncludeFromCartItemRecursive1(TypedDict, total=False):
    """Relational arguments for CartItem"""
    user: Union[bool, 'UserArgsFromCartItemRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromCartItemRecursive2']


class OrderIncludeFromCartItemRecursive2(TypedDict, total=False):
    """Relational arguments for CartItem"""
    user: Union[bool, 'UserArgsFromCartItemRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromCartItemRecursive3']


class OrderIncludeFromCartItemRecursive3(TypedDict, total=False):
    """Relational arguments for CartItem"""
    user: Union[bool, 'UserArgsFromCartItemRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromCartItemRecursive4']


class OrderIncludeFromCartItemRecursive4(TypedDict, total=False):
    """Relational arguments for CartItem"""

    

class OrderArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'OrderIncludeFromOrderRecursive1'


class OrderArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'OrderIncludeFromOrderRecursive2'


class OrderArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'OrderIncludeFromOrderRecursive3'


class OrderArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'OrderIncludeFromOrderRecursive4'


class OrderArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    
    

class FindManyOrderArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive1'


class FindManyOrderArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive2'


class FindManyOrderArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive3'


class FindManyOrderArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive4'


class FindManyOrderArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    
    

class OrderItemIncludeFromCartItem(TypedDict, total=False):
    """Relational arguments for CartItem"""
    order: Union[bool, 'OrderArgsFromCartItemRecursive1']
    product: Union[bool, 'ProductArgsFromCartItemRecursive1']
    pet: Union[bool, 'PetArgsFromCartItemRecursive1']


class OrderItemIncludeFromCartItemRecursive1(TypedDict, total=False):
    """Relational arguments for CartItem"""
    order: Union[bool, 'OrderArgsFromCartItemRecursive2']
    product: Union[bool, 'ProductArgsFromCartItemRecursive2']
    pet: Union[bool, 'PetArgsFromCartItemRecursive2']


class OrderItemIncludeFromCartItemRecursive2(TypedDict, total=False):
    """Relational arguments for CartItem"""
    order: Union[bool, 'OrderArgsFromCartItemRecursive3']
    product: Union[bool, 'ProductArgsFromCartItemRecursive3']
    pet: Union[bool, 'PetArgsFromCartItemRecursive3']


class OrderItemIncludeFromCartItemRecursive3(TypedDict, total=False):
    """Relational arguments for CartItem"""
    order: Union[bool, 'OrderArgsFromCartItemRecursive4']
    product: Union[bool, 'ProductArgsFromCartItemRecursive4']
    pet: Union[bool, 'PetArgsFromCartItemRecursive4']


class OrderItemIncludeFromCartItemRecursive4(TypedDict, total=False):
    """Relational arguments for CartItem"""

    

class OrderItemArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class OrderItemArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class OrderItemArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class OrderItemArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class OrderItemArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    
    

class FindManyOrderItemArgsFromCartItem(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class FindManyOrderItemArgsFromCartItemRecursive1(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class FindManyOrderItemArgsFromCartItemRecursive2(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class FindManyOrderItemArgsFromCartItemRecursive3(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class FindManyOrderItemArgsFromCartItemRecursive4(TypedDict, total=False):
    """Arguments for CartItem"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    


FindManyCartItemArgs = FindManyCartItemArgsFromCartItem
FindFirstCartItemArgs = FindManyCartItemArgsFromCartItem


    

class CartItemWhereInput(TypedDict, total=False):
    """CartItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    price: Union[_float, 'types.FloatFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CartItemWhereInputRecursive1', List['CartItemWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CartItemWhereInputRecursive1']
    OR: List['CartItemWhereInputRecursive1']
    NOT: List['CartItemWhereInputRecursive1']


class CartItemWhereInputRecursive1(TypedDict, total=False):
    """CartItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    price: Union[_float, 'types.FloatFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CartItemWhereInputRecursive2', List['CartItemWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CartItemWhereInputRecursive2']
    OR: List['CartItemWhereInputRecursive2']
    NOT: List['CartItemWhereInputRecursive2']


class CartItemWhereInputRecursive2(TypedDict, total=False):
    """CartItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    price: Union[_float, 'types.FloatFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CartItemWhereInputRecursive3', List['CartItemWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CartItemWhereInputRecursive3']
    OR: List['CartItemWhereInputRecursive3']
    NOT: List['CartItemWhereInputRecursive3']


class CartItemWhereInputRecursive3(TypedDict, total=False):
    """CartItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    price: Union[_float, 'types.FloatFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CartItemWhereInputRecursive4', List['CartItemWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CartItemWhereInputRecursive4']
    OR: List['CartItemWhereInputRecursive4']
    NOT: List['CartItemWhereInputRecursive4']


class CartItemWhereInputRecursive4(TypedDict, total=False):
    """CartItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    price: Union[_float, 'types.FloatFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate CartItem types


    

class CartItemScalarWhereWithAggregatesInput(TypedDict, total=False):
    """CartItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CartItemScalarWhereWithAggregatesInputRecursive1']
    OR: List['CartItemScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CartItemScalarWhereWithAggregatesInputRecursive1']


class CartItemScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """CartItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CartItemScalarWhereWithAggregatesInputRecursive2']
    OR: List['CartItemScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CartItemScalarWhereWithAggregatesInputRecursive2']


class CartItemScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """CartItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CartItemScalarWhereWithAggregatesInputRecursive3']
    OR: List['CartItemScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CartItemScalarWhereWithAggregatesInputRecursive3']


class CartItemScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """CartItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CartItemScalarWhereWithAggregatesInputRecursive4']
    OR: List['CartItemScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CartItemScalarWhereWithAggregatesInputRecursive4']


class CartItemScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """CartItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class CartItemGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    productId: _str
    petId: _str
    quantity: _int
    price: _float
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'CartItemSumAggregateOutput'
    _avg: 'CartItemAvgAggregateOutput'
    _min: 'CartItemMinAggregateOutput'
    _max: 'CartItemMaxAggregateOutput'
    _count: 'CartItemCountAggregateOutput'


class CartItemAvgAggregateOutput(TypedDict, total=False):
    """CartItem output for aggregating averages"""
    quantity: float
    price: float


class CartItemSumAggregateOutput(TypedDict, total=False):
    """CartItem output for aggregating sums"""
    quantity: _int
    price: _float


class CartItemScalarAggregateOutput(TypedDict, total=False):
    """CartItem output including scalar fields"""
    id: _str
    userId: _str
    productId: _str
    petId: _str
    quantity: _int
    price: _float
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


CartItemMinAggregateOutput = CartItemScalarAggregateOutput
CartItemMaxAggregateOutput = CartItemScalarAggregateOutput


class CartItemMaxAggregateInput(TypedDict, total=False):
    """CartItem input for aggregating by max"""
    id: bool
    userId: bool
    productId: bool
    petId: bool
    quantity: bool
    price: bool
    createdAt: bool
    updatedAt: bool


class CartItemMinAggregateInput(TypedDict, total=False):
    """CartItem input for aggregating by min"""
    id: bool
    userId: bool
    productId: bool
    petId: bool
    quantity: bool
    price: bool
    createdAt: bool
    updatedAt: bool


class CartItemNumberAggregateInput(TypedDict, total=False):
    """CartItem input for aggregating numbers"""
    quantity: bool
    price: bool


CartItemAvgAggregateInput = CartItemNumberAggregateInput
CartItemSumAggregateInput = CartItemNumberAggregateInput


CartItemCountAggregateInput = TypedDict(
    'CartItemCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'productId': bool,
        'petId': bool,
        'quantity': bool,
        'price': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

CartItemCountAggregateOutput = TypedDict(
    'CartItemCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'productId': int,
        'petId': int,
        'quantity': int,
        'price': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


CartItemKeys = Literal[
    'id',
    'userId',
    'user',
    'productId',
    'product',
    'petId',
    'pet',
    'quantity',
    'price',
    'createdAt',
    'updatedAt',
]
CartItemScalarFieldKeys = Literal[
    'id',
    'userId',
    'productId',
    'petId',
    'quantity',
    'price',
    'createdAt',
    'updatedAt',
]
CartItemScalarFieldKeysT = TypeVar('CartItemScalarFieldKeysT', bound=CartItemScalarFieldKeys)

CartItemRelationalFieldKeys = Literal[
        'user',
        'product',
        'pet',
    ]

# Wishlist types

class WishlistOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Wishlist create method"""
    id: _str
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    productId: Optional[_str]
    product: 'ProductCreateNestedWithoutRelationsInput'
    petId: Optional[_str]
    pet: 'PetCreateNestedWithoutRelationsInput'
    addedAt: datetime.datetime


class WishlistCreateInput(WishlistOptionalCreateInput):
    """Required arguments to the Wishlist create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class WishlistOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Wishlist create method, without relations"""
    id: _str
    userId: _str
    productId: Optional[_str]
    petId: Optional[_str]
    addedAt: datetime.datetime


class WishlistCreateWithoutRelationsInput(WishlistOptionalCreateWithoutRelationsInput):
    """Required arguments to the Wishlist create method, without relations"""


class WishlistCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'WishlistCreateWithoutRelationsInput'
    connect: 'WishlistWhereUniqueInput'


class WishlistCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['WishlistCreateWithoutRelationsInput', List['WishlistCreateWithoutRelationsInput']]
    connect: Union['WishlistWhereUniqueInput', List['WishlistWhereUniqueInput']]


_WishlistWhereUnique_id_Input = TypedDict(
    '_WishlistWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

WishlistWhereUniqueInput = _WishlistWhereUnique_id_Input


class WishlistUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    user: 'UserUpdateOneWithoutRelationsInput'
    product: 'ProductUpdateOneWithoutRelationsInput'
    pet: 'PetUpdateOneWithoutRelationsInput'
    addedAt: datetime.datetime


class WishlistUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    addedAt: datetime.datetime


class WishlistUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['WishlistCreateWithoutRelationsInput']
    connect: List['WishlistWhereUniqueInput']
    set: List['WishlistWhereUniqueInput']
    disconnect: List['WishlistWhereUniqueInput']
    delete: List['WishlistWhereUniqueInput']

    # TODO
    # update: List['WishlistUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['WishlistUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['WishlistScalarWhereInput']
    # upsert: List['WishlistUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['WishlistCreateOrConnectWithoutRelationsInput']


class WishlistUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'WishlistCreateWithoutRelationsInput'
    connect: 'WishlistWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'WishlistUpdateInput'
    # upsert: 'WishlistUpsertWithoutRelationsInput'
    # connectOrCreate: 'WishlistCreateOrConnectWithoutRelationsInput'


class WishlistUpsertInput(TypedDict):
    create: 'WishlistCreateInput'
    update: 'WishlistUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Wishlist_id_OrderByInput = TypedDict(
    '_Wishlist_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Wishlist_userId_OrderByInput = TypedDict(
    '_Wishlist_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Wishlist_productId_OrderByInput = TypedDict(
    '_Wishlist_productId_OrderByInput',
    {
        'productId': 'SortOrder',
    },
    total=True
)

_Wishlist_petId_OrderByInput = TypedDict(
    '_Wishlist_petId_OrderByInput',
    {
        'petId': 'SortOrder',
    },
    total=True
)

_Wishlist_addedAt_OrderByInput = TypedDict(
    '_Wishlist_addedAt_OrderByInput',
    {
        'addedAt': 'SortOrder',
    },
    total=True
)

WishlistOrderByInput = Union[
    '_Wishlist_id_OrderByInput',
    '_Wishlist_userId_OrderByInput',
    '_Wishlist_productId_OrderByInput',
    '_Wishlist_petId_OrderByInput',
    '_Wishlist_addedAt_OrderByInput',
]



# recursive Wishlist types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

WishlistRelationFilter = TypedDict(
    'WishlistRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class WishlistListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class WishlistInclude(TypedDict, total=False):
    """Wishlist relational arguments"""
    user: Union[bool, 'UserArgsFromWishlist']
    product: Union[bool, 'ProductArgsFromWishlist']
    pet: Union[bool, 'PetArgsFromWishlist']


    

class UserIncludeFromWishlist(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromWishlistRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromWishlistRecursive1']
    orders: Union[bool, 'FindManyOrderArgsFromWishlistRecursive1']


class UserIncludeFromWishlistRecursive1(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromWishlistRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromWishlistRecursive2']
    orders: Union[bool, 'FindManyOrderArgsFromWishlistRecursive2']


class UserIncludeFromWishlistRecursive2(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromWishlistRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromWishlistRecursive3']
    orders: Union[bool, 'FindManyOrderArgsFromWishlistRecursive3']


class UserIncludeFromWishlistRecursive3(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromWishlistRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromWishlistRecursive4']
    orders: Union[bool, 'FindManyOrderArgsFromWishlistRecursive4']


class UserIncludeFromWishlistRecursive4(TypedDict, total=False):
    """Relational arguments for Wishlist"""

    

class UserArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    
    

class FindManyUserArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class PetIncludeFromWishlist(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromWishlistRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromWishlistRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromWishlistRecursive1']


class PetIncludeFromWishlistRecursive1(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromWishlistRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromWishlistRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromWishlistRecursive2']


class PetIncludeFromWishlistRecursive2(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromWishlistRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromWishlistRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromWishlistRecursive3']


class PetIncludeFromWishlistRecursive3(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromWishlistRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromWishlistRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromWishlistRecursive4']


class PetIncludeFromWishlistRecursive4(TypedDict, total=False):
    """Relational arguments for Wishlist"""

    

class PetArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'PetIncludeFromPetRecursive1'


class PetArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'PetIncludeFromPetRecursive2'


class PetArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'PetIncludeFromPetRecursive3'


class PetArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'PetIncludeFromPetRecursive4'


class PetArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    
    

class FindManyPetArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive1'


class FindManyPetArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive2'


class FindManyPetArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive3'


class FindManyPetArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive4'


class FindManyPetArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    
    

class ProductIncludeFromWishlist(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromWishlistRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromWishlistRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromWishlistRecursive1']


class ProductIncludeFromWishlistRecursive1(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromWishlistRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromWishlistRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromWishlistRecursive2']


class ProductIncludeFromWishlistRecursive2(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromWishlistRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromWishlistRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromWishlistRecursive3']


class ProductIncludeFromWishlistRecursive3(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromWishlistRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromWishlistRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromWishlistRecursive4']


class ProductIncludeFromWishlistRecursive4(TypedDict, total=False):
    """Relational arguments for Wishlist"""

    

class ProductArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'ProductIncludeFromProductRecursive1'


class ProductArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'ProductIncludeFromProductRecursive2'


class ProductArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'ProductIncludeFromProductRecursive3'


class ProductArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'ProductIncludeFromProductRecursive4'


class ProductArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    
    

class FindManyProductArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive1'


class FindManyProductArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive2'


class FindManyProductArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive3'


class FindManyProductArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive4'


class FindManyProductArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    
    

class CartItemIncludeFromWishlist(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    user: Union[bool, 'UserArgsFromWishlistRecursive1']
    product: Union[bool, 'ProductArgsFromWishlistRecursive1']
    pet: Union[bool, 'PetArgsFromWishlistRecursive1']


class CartItemIncludeFromWishlistRecursive1(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    user: Union[bool, 'UserArgsFromWishlistRecursive2']
    product: Union[bool, 'ProductArgsFromWishlistRecursive2']
    pet: Union[bool, 'PetArgsFromWishlistRecursive2']


class CartItemIncludeFromWishlistRecursive2(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    user: Union[bool, 'UserArgsFromWishlistRecursive3']
    product: Union[bool, 'ProductArgsFromWishlistRecursive3']
    pet: Union[bool, 'PetArgsFromWishlistRecursive3']


class CartItemIncludeFromWishlistRecursive3(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    user: Union[bool, 'UserArgsFromWishlistRecursive4']
    product: Union[bool, 'ProductArgsFromWishlistRecursive4']
    pet: Union[bool, 'PetArgsFromWishlistRecursive4']


class CartItemIncludeFromWishlistRecursive4(TypedDict, total=False):
    """Relational arguments for Wishlist"""

    

class CartItemArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'CartItemIncludeFromCartItemRecursive1'


class CartItemArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'CartItemIncludeFromCartItemRecursive2'


class CartItemArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'CartItemIncludeFromCartItemRecursive3'


class CartItemArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'CartItemIncludeFromCartItemRecursive4'


class CartItemArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    
    

class FindManyCartItemArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive1'


class FindManyCartItemArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive2'


class FindManyCartItemArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive3'


class FindManyCartItemArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive4'


class FindManyCartItemArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    
    

class WishlistIncludeFromWishlist(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    user: Union[bool, 'UserArgsFromWishlistRecursive1']
    product: Union[bool, 'ProductArgsFromWishlistRecursive1']
    pet: Union[bool, 'PetArgsFromWishlistRecursive1']


class WishlistIncludeFromWishlistRecursive1(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    user: Union[bool, 'UserArgsFromWishlistRecursive2']
    product: Union[bool, 'ProductArgsFromWishlistRecursive2']
    pet: Union[bool, 'PetArgsFromWishlistRecursive2']


class WishlistIncludeFromWishlistRecursive2(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    user: Union[bool, 'UserArgsFromWishlistRecursive3']
    product: Union[bool, 'ProductArgsFromWishlistRecursive3']
    pet: Union[bool, 'PetArgsFromWishlistRecursive3']


class WishlistIncludeFromWishlistRecursive3(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    user: Union[bool, 'UserArgsFromWishlistRecursive4']
    product: Union[bool, 'ProductArgsFromWishlistRecursive4']
    pet: Union[bool, 'PetArgsFromWishlistRecursive4']


class WishlistIncludeFromWishlistRecursive4(TypedDict, total=False):
    """Relational arguments for Wishlist"""

    

class WishlistArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'WishlistIncludeFromWishlistRecursive1'


class WishlistArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'WishlistIncludeFromWishlistRecursive2'


class WishlistArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'WishlistIncludeFromWishlistRecursive3'


class WishlistArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'WishlistIncludeFromWishlistRecursive4'


class WishlistArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    
    

class FindManyWishlistArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive1'


class FindManyWishlistArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive2'


class FindManyWishlistArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive3'


class FindManyWishlistArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive4'


class FindManyWishlistArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    
    

class OrderIncludeFromWishlist(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    user: Union[bool, 'UserArgsFromWishlistRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromWishlistRecursive1']


class OrderIncludeFromWishlistRecursive1(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    user: Union[bool, 'UserArgsFromWishlistRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromWishlistRecursive2']


class OrderIncludeFromWishlistRecursive2(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    user: Union[bool, 'UserArgsFromWishlistRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromWishlistRecursive3']


class OrderIncludeFromWishlistRecursive3(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    user: Union[bool, 'UserArgsFromWishlistRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromWishlistRecursive4']


class OrderIncludeFromWishlistRecursive4(TypedDict, total=False):
    """Relational arguments for Wishlist"""

    

class OrderArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'OrderIncludeFromOrderRecursive1'


class OrderArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'OrderIncludeFromOrderRecursive2'


class OrderArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'OrderIncludeFromOrderRecursive3'


class OrderArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'OrderIncludeFromOrderRecursive4'


class OrderArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    
    

class FindManyOrderArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive1'


class FindManyOrderArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive2'


class FindManyOrderArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive3'


class FindManyOrderArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive4'


class FindManyOrderArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    
    

class OrderItemIncludeFromWishlist(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    order: Union[bool, 'OrderArgsFromWishlistRecursive1']
    product: Union[bool, 'ProductArgsFromWishlistRecursive1']
    pet: Union[bool, 'PetArgsFromWishlistRecursive1']


class OrderItemIncludeFromWishlistRecursive1(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    order: Union[bool, 'OrderArgsFromWishlistRecursive2']
    product: Union[bool, 'ProductArgsFromWishlistRecursive2']
    pet: Union[bool, 'PetArgsFromWishlistRecursive2']


class OrderItemIncludeFromWishlistRecursive2(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    order: Union[bool, 'OrderArgsFromWishlistRecursive3']
    product: Union[bool, 'ProductArgsFromWishlistRecursive3']
    pet: Union[bool, 'PetArgsFromWishlistRecursive3']


class OrderItemIncludeFromWishlistRecursive3(TypedDict, total=False):
    """Relational arguments for Wishlist"""
    order: Union[bool, 'OrderArgsFromWishlistRecursive4']
    product: Union[bool, 'ProductArgsFromWishlistRecursive4']
    pet: Union[bool, 'PetArgsFromWishlistRecursive4']


class OrderItemIncludeFromWishlistRecursive4(TypedDict, total=False):
    """Relational arguments for Wishlist"""

    

class OrderItemArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class OrderItemArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class OrderItemArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class OrderItemArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class OrderItemArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    
    

class FindManyOrderItemArgsFromWishlist(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class FindManyOrderItemArgsFromWishlistRecursive1(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class FindManyOrderItemArgsFromWishlistRecursive2(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class FindManyOrderItemArgsFromWishlistRecursive3(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class FindManyOrderItemArgsFromWishlistRecursive4(TypedDict, total=False):
    """Arguments for Wishlist"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    


FindManyWishlistArgs = FindManyWishlistArgsFromWishlist
FindFirstWishlistArgs = FindManyWishlistArgsFromWishlist


    

class WishlistWhereInput(TypedDict, total=False):
    """Wishlist arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    addedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['WishlistWhereInputRecursive1', List['WishlistWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['WishlistWhereInputRecursive1']
    OR: List['WishlistWhereInputRecursive1']
    NOT: List['WishlistWhereInputRecursive1']


class WishlistWhereInputRecursive1(TypedDict, total=False):
    """Wishlist arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    addedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['WishlistWhereInputRecursive2', List['WishlistWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['WishlistWhereInputRecursive2']
    OR: List['WishlistWhereInputRecursive2']
    NOT: List['WishlistWhereInputRecursive2']


class WishlistWhereInputRecursive2(TypedDict, total=False):
    """Wishlist arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    addedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['WishlistWhereInputRecursive3', List['WishlistWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['WishlistWhereInputRecursive3']
    OR: List['WishlistWhereInputRecursive3']
    NOT: List['WishlistWhereInputRecursive3']


class WishlistWhereInputRecursive3(TypedDict, total=False):
    """Wishlist arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    addedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['WishlistWhereInputRecursive4', List['WishlistWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['WishlistWhereInputRecursive4']
    OR: List['WishlistWhereInputRecursive4']
    NOT: List['WishlistWhereInputRecursive4']


class WishlistWhereInputRecursive4(TypedDict, total=False):
    """Wishlist arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    addedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Wishlist types


    

class WishlistScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Wishlist arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    addedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WishlistScalarWhereWithAggregatesInputRecursive1']
    OR: List['WishlistScalarWhereWithAggregatesInputRecursive1']
    NOT: List['WishlistScalarWhereWithAggregatesInputRecursive1']


class WishlistScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Wishlist arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    addedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WishlistScalarWhereWithAggregatesInputRecursive2']
    OR: List['WishlistScalarWhereWithAggregatesInputRecursive2']
    NOT: List['WishlistScalarWhereWithAggregatesInputRecursive2']


class WishlistScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Wishlist arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    addedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WishlistScalarWhereWithAggregatesInputRecursive3']
    OR: List['WishlistScalarWhereWithAggregatesInputRecursive3']
    NOT: List['WishlistScalarWhereWithAggregatesInputRecursive3']


class WishlistScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Wishlist arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    addedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WishlistScalarWhereWithAggregatesInputRecursive4']
    OR: List['WishlistScalarWhereWithAggregatesInputRecursive4']
    NOT: List['WishlistScalarWhereWithAggregatesInputRecursive4']


class WishlistScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Wishlist arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    addedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class WishlistGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    productId: _str
    petId: _str
    addedAt: datetime.datetime
    _sum: 'WishlistSumAggregateOutput'
    _avg: 'WishlistAvgAggregateOutput'
    _min: 'WishlistMinAggregateOutput'
    _max: 'WishlistMaxAggregateOutput'
    _count: 'WishlistCountAggregateOutput'


class WishlistAvgAggregateOutput(TypedDict, total=False):
    """Wishlist output for aggregating averages"""


class WishlistSumAggregateOutput(TypedDict, total=False):
    """Wishlist output for aggregating sums"""


class WishlistScalarAggregateOutput(TypedDict, total=False):
    """Wishlist output including scalar fields"""
    id: _str
    userId: _str
    productId: _str
    petId: _str
    addedAt: datetime.datetime


WishlistMinAggregateOutput = WishlistScalarAggregateOutput
WishlistMaxAggregateOutput = WishlistScalarAggregateOutput


class WishlistMaxAggregateInput(TypedDict, total=False):
    """Wishlist input for aggregating by max"""
    id: bool
    userId: bool
    productId: bool
    petId: bool
    addedAt: bool


class WishlistMinAggregateInput(TypedDict, total=False):
    """Wishlist input for aggregating by min"""
    id: bool
    userId: bool
    productId: bool
    petId: bool
    addedAt: bool


class WishlistNumberAggregateInput(TypedDict, total=False):
    """Wishlist input for aggregating numbers"""


WishlistAvgAggregateInput = WishlistNumberAggregateInput
WishlistSumAggregateInput = WishlistNumberAggregateInput


WishlistCountAggregateInput = TypedDict(
    'WishlistCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'productId': bool,
        'petId': bool,
        'addedAt': bool,
        '_all': bool,
    },
    total=False,
)

WishlistCountAggregateOutput = TypedDict(
    'WishlistCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'productId': int,
        'petId': int,
        'addedAt': int,
        '_all': int,
    },
    total=False,
)


WishlistKeys = Literal[
    'id',
    'userId',
    'user',
    'productId',
    'product',
    'petId',
    'pet',
    'addedAt',
]
WishlistScalarFieldKeys = Literal[
    'id',
    'userId',
    'productId',
    'petId',
    'addedAt',
]
WishlistScalarFieldKeysT = TypeVar('WishlistScalarFieldKeysT', bound=WishlistScalarFieldKeys)

WishlistRelationalFieldKeys = Literal[
        'user',
        'product',
        'pet',
    ]

# Order types

class OrderOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Order create method"""
    id: _str
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    status: _str
    pickupLocation: Optional[_str]
    trackingNumber: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    orderItems: 'OrderItemCreateManyNestedWithoutRelationsInput'


class OrderCreateInput(OrderOptionalCreateInput):
    """Required arguments to the Order create method"""
    totalPrice: _float
    shippingAddress: _str
    deliveryOption: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class OrderOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Order create method, without relations"""
    id: _str
    userId: _str
    status: _str
    pickupLocation: Optional[_str]
    trackingNumber: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class OrderCreateWithoutRelationsInput(OrderOptionalCreateWithoutRelationsInput):
    """Required arguments to the Order create method, without relations"""
    totalPrice: _float
    shippingAddress: _str
    deliveryOption: _str


class OrderCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'OrderCreateWithoutRelationsInput'
    connect: 'OrderWhereUniqueInput'


class OrderCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['OrderCreateWithoutRelationsInput', List['OrderCreateWithoutRelationsInput']]
    connect: Union['OrderWhereUniqueInput', List['OrderWhereUniqueInput']]


_OrderWhereUnique_id_Input = TypedDict(
    '_OrderWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

OrderWhereUniqueInput = _OrderWhereUnique_id_Input


class OrderUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    user: 'UserUpdateOneWithoutRelationsInput'
    status: _str
    totalPrice: Union[AtomicFloatInput, _float]
    shippingAddress: _str
    deliveryOption: _str
    pickupLocation: Optional[_str]
    trackingNumber: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    orderItems: 'OrderItemUpdateManyWithoutRelationsInput'


class OrderUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    status: _str
    totalPrice: Union[AtomicFloatInput, _float]
    shippingAddress: _str
    deliveryOption: _str
    pickupLocation: Optional[_str]
    trackingNumber: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class OrderUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['OrderCreateWithoutRelationsInput']
    connect: List['OrderWhereUniqueInput']
    set: List['OrderWhereUniqueInput']
    disconnect: List['OrderWhereUniqueInput']
    delete: List['OrderWhereUniqueInput']

    # TODO
    # update: List['OrderUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['OrderUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['OrderScalarWhereInput']
    # upsert: List['OrderUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['OrderCreateOrConnectWithoutRelationsInput']


class OrderUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'OrderCreateWithoutRelationsInput'
    connect: 'OrderWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'OrderUpdateInput'
    # upsert: 'OrderUpsertWithoutRelationsInput'
    # connectOrCreate: 'OrderCreateOrConnectWithoutRelationsInput'


class OrderUpsertInput(TypedDict):
    create: 'OrderCreateInput'
    update: 'OrderUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Order_id_OrderByInput = TypedDict(
    '_Order_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Order_userId_OrderByInput = TypedDict(
    '_Order_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Order_status_OrderByInput = TypedDict(
    '_Order_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Order_totalPrice_OrderByInput = TypedDict(
    '_Order_totalPrice_OrderByInput',
    {
        'totalPrice': 'SortOrder',
    },
    total=True
)

_Order_shippingAddress_OrderByInput = TypedDict(
    '_Order_shippingAddress_OrderByInput',
    {
        'shippingAddress': 'SortOrder',
    },
    total=True
)

_Order_deliveryOption_OrderByInput = TypedDict(
    '_Order_deliveryOption_OrderByInput',
    {
        'deliveryOption': 'SortOrder',
    },
    total=True
)

_Order_pickupLocation_OrderByInput = TypedDict(
    '_Order_pickupLocation_OrderByInput',
    {
        'pickupLocation': 'SortOrder',
    },
    total=True
)

_Order_trackingNumber_OrderByInput = TypedDict(
    '_Order_trackingNumber_OrderByInput',
    {
        'trackingNumber': 'SortOrder',
    },
    total=True
)

_Order_createdAt_OrderByInput = TypedDict(
    '_Order_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Order_updatedAt_OrderByInput = TypedDict(
    '_Order_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

OrderOrderByInput = Union[
    '_Order_id_OrderByInput',
    '_Order_userId_OrderByInput',
    '_Order_status_OrderByInput',
    '_Order_totalPrice_OrderByInput',
    '_Order_shippingAddress_OrderByInput',
    '_Order_deliveryOption_OrderByInput',
    '_Order_pickupLocation_OrderByInput',
    '_Order_trackingNumber_OrderByInput',
    '_Order_createdAt_OrderByInput',
    '_Order_updatedAt_OrderByInput',
]



# recursive Order types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

OrderRelationFilter = TypedDict(
    'OrderRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class OrderListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class OrderInclude(TypedDict, total=False):
    """Order relational arguments"""
    user: Union[bool, 'UserArgsFromOrder']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrder']


    

class UserIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderRecursive1']
    orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive1']


class UserIncludeFromOrderRecursive1(TypedDict, total=False):
    """Relational arguments for Order"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderRecursive2']
    orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive2']


class UserIncludeFromOrderRecursive2(TypedDict, total=False):
    """Relational arguments for Order"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderRecursive3']
    orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive3']


class UserIncludeFromOrderRecursive3(TypedDict, total=False):
    """Relational arguments for Order"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderRecursive4']
    orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive4']


class UserIncludeFromOrderRecursive4(TypedDict, total=False):
    """Relational arguments for Order"""

    

class UserArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    
    

class FindManyUserArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class PetIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderRecursive1']


class PetIncludeFromOrderRecursive1(TypedDict, total=False):
    """Relational arguments for Order"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderRecursive2']


class PetIncludeFromOrderRecursive2(TypedDict, total=False):
    """Relational arguments for Order"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderRecursive3']


class PetIncludeFromOrderRecursive3(TypedDict, total=False):
    """Relational arguments for Order"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderRecursive4']


class PetIncludeFromOrderRecursive4(TypedDict, total=False):
    """Relational arguments for Order"""

    

class PetArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'PetIncludeFromPetRecursive1'


class PetArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    include: 'PetIncludeFromPetRecursive2'


class PetArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    include: 'PetIncludeFromPetRecursive3'


class PetArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    include: 'PetIncludeFromPetRecursive4'


class PetArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    
    

class FindManyPetArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive1'


class FindManyPetArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive2'


class FindManyPetArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive3'


class FindManyPetArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive4'


class FindManyPetArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    
    

class ProductIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderRecursive1']


class ProductIncludeFromOrderRecursive1(TypedDict, total=False):
    """Relational arguments for Order"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderRecursive2']


class ProductIncludeFromOrderRecursive2(TypedDict, total=False):
    """Relational arguments for Order"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderRecursive3']


class ProductIncludeFromOrderRecursive3(TypedDict, total=False):
    """Relational arguments for Order"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderRecursive4']


class ProductIncludeFromOrderRecursive4(TypedDict, total=False):
    """Relational arguments for Order"""

    

class ProductArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ProductIncludeFromProductRecursive1'


class ProductArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ProductIncludeFromProductRecursive2'


class ProductArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ProductIncludeFromProductRecursive3'


class ProductArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ProductIncludeFromProductRecursive4'


class ProductArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    
    

class FindManyProductArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive1'


class FindManyProductArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive2'


class FindManyProductArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive3'


class FindManyProductArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive4'


class FindManyProductArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    
    

class CartItemIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    user: Union[bool, 'UserArgsFromOrderRecursive1']
    product: Union[bool, 'ProductArgsFromOrderRecursive1']
    pet: Union[bool, 'PetArgsFromOrderRecursive1']


class CartItemIncludeFromOrderRecursive1(TypedDict, total=False):
    """Relational arguments for Order"""
    user: Union[bool, 'UserArgsFromOrderRecursive2']
    product: Union[bool, 'ProductArgsFromOrderRecursive2']
    pet: Union[bool, 'PetArgsFromOrderRecursive2']


class CartItemIncludeFromOrderRecursive2(TypedDict, total=False):
    """Relational arguments for Order"""
    user: Union[bool, 'UserArgsFromOrderRecursive3']
    product: Union[bool, 'ProductArgsFromOrderRecursive3']
    pet: Union[bool, 'PetArgsFromOrderRecursive3']


class CartItemIncludeFromOrderRecursive3(TypedDict, total=False):
    """Relational arguments for Order"""
    user: Union[bool, 'UserArgsFromOrderRecursive4']
    product: Union[bool, 'ProductArgsFromOrderRecursive4']
    pet: Union[bool, 'PetArgsFromOrderRecursive4']


class CartItemIncludeFromOrderRecursive4(TypedDict, total=False):
    """Relational arguments for Order"""

    

class CartItemArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'CartItemIncludeFromCartItemRecursive1'


class CartItemArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    include: 'CartItemIncludeFromCartItemRecursive2'


class CartItemArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    include: 'CartItemIncludeFromCartItemRecursive3'


class CartItemArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    include: 'CartItemIncludeFromCartItemRecursive4'


class CartItemArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    
    

class FindManyCartItemArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive1'


class FindManyCartItemArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive2'


class FindManyCartItemArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive3'


class FindManyCartItemArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive4'


class FindManyCartItemArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    
    

class WishlistIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    user: Union[bool, 'UserArgsFromOrderRecursive1']
    product: Union[bool, 'ProductArgsFromOrderRecursive1']
    pet: Union[bool, 'PetArgsFromOrderRecursive1']


class WishlistIncludeFromOrderRecursive1(TypedDict, total=False):
    """Relational arguments for Order"""
    user: Union[bool, 'UserArgsFromOrderRecursive2']
    product: Union[bool, 'ProductArgsFromOrderRecursive2']
    pet: Union[bool, 'PetArgsFromOrderRecursive2']


class WishlistIncludeFromOrderRecursive2(TypedDict, total=False):
    """Relational arguments for Order"""
    user: Union[bool, 'UserArgsFromOrderRecursive3']
    product: Union[bool, 'ProductArgsFromOrderRecursive3']
    pet: Union[bool, 'PetArgsFromOrderRecursive3']


class WishlistIncludeFromOrderRecursive3(TypedDict, total=False):
    """Relational arguments for Order"""
    user: Union[bool, 'UserArgsFromOrderRecursive4']
    product: Union[bool, 'ProductArgsFromOrderRecursive4']
    pet: Union[bool, 'PetArgsFromOrderRecursive4']


class WishlistIncludeFromOrderRecursive4(TypedDict, total=False):
    """Relational arguments for Order"""

    

class WishlistArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'WishlistIncludeFromWishlistRecursive1'


class WishlistArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    include: 'WishlistIncludeFromWishlistRecursive2'


class WishlistArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    include: 'WishlistIncludeFromWishlistRecursive3'


class WishlistArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    include: 'WishlistIncludeFromWishlistRecursive4'


class WishlistArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    
    

class FindManyWishlistArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive1'


class FindManyWishlistArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive2'


class FindManyWishlistArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive3'


class FindManyWishlistArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive4'


class FindManyWishlistArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    
    

class OrderIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    user: Union[bool, 'UserArgsFromOrderRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderRecursive1']


class OrderIncludeFromOrderRecursive1(TypedDict, total=False):
    """Relational arguments for Order"""
    user: Union[bool, 'UserArgsFromOrderRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderRecursive2']


class OrderIncludeFromOrderRecursive2(TypedDict, total=False):
    """Relational arguments for Order"""
    user: Union[bool, 'UserArgsFromOrderRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderRecursive3']


class OrderIncludeFromOrderRecursive3(TypedDict, total=False):
    """Relational arguments for Order"""
    user: Union[bool, 'UserArgsFromOrderRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderRecursive4']


class OrderIncludeFromOrderRecursive4(TypedDict, total=False):
    """Relational arguments for Order"""

    

class OrderArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderIncludeFromOrderRecursive1'


class OrderArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderIncludeFromOrderRecursive2'


class OrderArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderIncludeFromOrderRecursive3'


class OrderArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderIncludeFromOrderRecursive4'


class OrderArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    
    

class FindManyOrderArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive1'


class FindManyOrderArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive2'


class FindManyOrderArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive3'


class FindManyOrderArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive4'


class FindManyOrderArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    
    

class OrderItemIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    order: Union[bool, 'OrderArgsFromOrderRecursive1']
    product: Union[bool, 'ProductArgsFromOrderRecursive1']
    pet: Union[bool, 'PetArgsFromOrderRecursive1']


class OrderItemIncludeFromOrderRecursive1(TypedDict, total=False):
    """Relational arguments for Order"""
    order: Union[bool, 'OrderArgsFromOrderRecursive2']
    product: Union[bool, 'ProductArgsFromOrderRecursive2']
    pet: Union[bool, 'PetArgsFromOrderRecursive2']


class OrderItemIncludeFromOrderRecursive2(TypedDict, total=False):
    """Relational arguments for Order"""
    order: Union[bool, 'OrderArgsFromOrderRecursive3']
    product: Union[bool, 'ProductArgsFromOrderRecursive3']
    pet: Union[bool, 'PetArgsFromOrderRecursive3']


class OrderItemIncludeFromOrderRecursive3(TypedDict, total=False):
    """Relational arguments for Order"""
    order: Union[bool, 'OrderArgsFromOrderRecursive4']
    product: Union[bool, 'ProductArgsFromOrderRecursive4']
    pet: Union[bool, 'PetArgsFromOrderRecursive4']


class OrderItemIncludeFromOrderRecursive4(TypedDict, total=False):
    """Relational arguments for Order"""

    

class OrderItemArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class OrderItemArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class OrderItemArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class OrderItemArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class OrderItemArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    
    

class FindManyOrderItemArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class FindManyOrderItemArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class FindManyOrderItemArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class FindManyOrderItemArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class FindManyOrderItemArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    


FindManyOrderArgs = FindManyOrderArgsFromOrder
FindFirstOrderArgs = FindManyOrderArgsFromOrder


    

class OrderWhereInput(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    status: Union[_str, 'types.StringFilter']
    totalPrice: Union[_float, 'types.FloatFilter']
    shippingAddress: Union[_str, 'types.StringFilter']
    deliveryOption: Union[_str, 'types.StringFilter']
    pickupLocation: Union[None, _str, 'types.StringFilter']
    trackingNumber: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    orderItems: 'OrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['OrderWhereInputRecursive1', List['OrderWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['OrderWhereInputRecursive1']
    OR: List['OrderWhereInputRecursive1']
    NOT: List['OrderWhereInputRecursive1']


class OrderWhereInputRecursive1(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    status: Union[_str, 'types.StringFilter']
    totalPrice: Union[_float, 'types.FloatFilter']
    shippingAddress: Union[_str, 'types.StringFilter']
    deliveryOption: Union[_str, 'types.StringFilter']
    pickupLocation: Union[None, _str, 'types.StringFilter']
    trackingNumber: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    orderItems: 'OrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['OrderWhereInputRecursive2', List['OrderWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['OrderWhereInputRecursive2']
    OR: List['OrderWhereInputRecursive2']
    NOT: List['OrderWhereInputRecursive2']


class OrderWhereInputRecursive2(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    status: Union[_str, 'types.StringFilter']
    totalPrice: Union[_float, 'types.FloatFilter']
    shippingAddress: Union[_str, 'types.StringFilter']
    deliveryOption: Union[_str, 'types.StringFilter']
    pickupLocation: Union[None, _str, 'types.StringFilter']
    trackingNumber: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    orderItems: 'OrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['OrderWhereInputRecursive3', List['OrderWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['OrderWhereInputRecursive3']
    OR: List['OrderWhereInputRecursive3']
    NOT: List['OrderWhereInputRecursive3']


class OrderWhereInputRecursive3(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    status: Union[_str, 'types.StringFilter']
    totalPrice: Union[_float, 'types.FloatFilter']
    shippingAddress: Union[_str, 'types.StringFilter']
    deliveryOption: Union[_str, 'types.StringFilter']
    pickupLocation: Union[None, _str, 'types.StringFilter']
    trackingNumber: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    orderItems: 'OrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['OrderWhereInputRecursive4', List['OrderWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['OrderWhereInputRecursive4']
    OR: List['OrderWhereInputRecursive4']
    NOT: List['OrderWhereInputRecursive4']


class OrderWhereInputRecursive4(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    status: Union[_str, 'types.StringFilter']
    totalPrice: Union[_float, 'types.FloatFilter']
    shippingAddress: Union[_str, 'types.StringFilter']
    deliveryOption: Union[_str, 'types.StringFilter']
    pickupLocation: Union[None, _str, 'types.StringFilter']
    trackingNumber: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    orderItems: 'OrderItemListRelationFilter'



# aggregate Order types


    

class OrderScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    totalPrice: Union[_float, 'types.FloatWithAggregatesFilter']
    shippingAddress: Union[_str, 'types.StringWithAggregatesFilter']
    deliveryOption: Union[_str, 'types.StringWithAggregatesFilter']
    pickupLocation: Union[_str, 'types.StringWithAggregatesFilter']
    trackingNumber: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['OrderScalarWhereWithAggregatesInputRecursive1']
    OR: List['OrderScalarWhereWithAggregatesInputRecursive1']
    NOT: List['OrderScalarWhereWithAggregatesInputRecursive1']


class OrderScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    totalPrice: Union[_float, 'types.FloatWithAggregatesFilter']
    shippingAddress: Union[_str, 'types.StringWithAggregatesFilter']
    deliveryOption: Union[_str, 'types.StringWithAggregatesFilter']
    pickupLocation: Union[_str, 'types.StringWithAggregatesFilter']
    trackingNumber: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['OrderScalarWhereWithAggregatesInputRecursive2']
    OR: List['OrderScalarWhereWithAggregatesInputRecursive2']
    NOT: List['OrderScalarWhereWithAggregatesInputRecursive2']


class OrderScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    totalPrice: Union[_float, 'types.FloatWithAggregatesFilter']
    shippingAddress: Union[_str, 'types.StringWithAggregatesFilter']
    deliveryOption: Union[_str, 'types.StringWithAggregatesFilter']
    pickupLocation: Union[_str, 'types.StringWithAggregatesFilter']
    trackingNumber: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['OrderScalarWhereWithAggregatesInputRecursive3']
    OR: List['OrderScalarWhereWithAggregatesInputRecursive3']
    NOT: List['OrderScalarWhereWithAggregatesInputRecursive3']


class OrderScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    totalPrice: Union[_float, 'types.FloatWithAggregatesFilter']
    shippingAddress: Union[_str, 'types.StringWithAggregatesFilter']
    deliveryOption: Union[_str, 'types.StringWithAggregatesFilter']
    pickupLocation: Union[_str, 'types.StringWithAggregatesFilter']
    trackingNumber: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['OrderScalarWhereWithAggregatesInputRecursive4']
    OR: List['OrderScalarWhereWithAggregatesInputRecursive4']
    NOT: List['OrderScalarWhereWithAggregatesInputRecursive4']


class OrderScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    totalPrice: Union[_float, 'types.FloatWithAggregatesFilter']
    shippingAddress: Union[_str, 'types.StringWithAggregatesFilter']
    deliveryOption: Union[_str, 'types.StringWithAggregatesFilter']
    pickupLocation: Union[_str, 'types.StringWithAggregatesFilter']
    trackingNumber: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class OrderGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    status: _str
    totalPrice: _float
    shippingAddress: _str
    deliveryOption: _str
    pickupLocation: _str
    trackingNumber: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'OrderSumAggregateOutput'
    _avg: 'OrderAvgAggregateOutput'
    _min: 'OrderMinAggregateOutput'
    _max: 'OrderMaxAggregateOutput'
    _count: 'OrderCountAggregateOutput'


class OrderAvgAggregateOutput(TypedDict, total=False):
    """Order output for aggregating averages"""
    totalPrice: float


class OrderSumAggregateOutput(TypedDict, total=False):
    """Order output for aggregating sums"""
    totalPrice: _float


class OrderScalarAggregateOutput(TypedDict, total=False):
    """Order output including scalar fields"""
    id: _str
    userId: _str
    status: _str
    totalPrice: _float
    shippingAddress: _str
    deliveryOption: _str
    pickupLocation: _str
    trackingNumber: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


OrderMinAggregateOutput = OrderScalarAggregateOutput
OrderMaxAggregateOutput = OrderScalarAggregateOutput


class OrderMaxAggregateInput(TypedDict, total=False):
    """Order input for aggregating by max"""
    id: bool
    userId: bool
    status: bool
    totalPrice: bool
    shippingAddress: bool
    deliveryOption: bool
    pickupLocation: bool
    trackingNumber: bool
    createdAt: bool
    updatedAt: bool


class OrderMinAggregateInput(TypedDict, total=False):
    """Order input for aggregating by min"""
    id: bool
    userId: bool
    status: bool
    totalPrice: bool
    shippingAddress: bool
    deliveryOption: bool
    pickupLocation: bool
    trackingNumber: bool
    createdAt: bool
    updatedAt: bool


class OrderNumberAggregateInput(TypedDict, total=False):
    """Order input for aggregating numbers"""
    totalPrice: bool


OrderAvgAggregateInput = OrderNumberAggregateInput
OrderSumAggregateInput = OrderNumberAggregateInput


OrderCountAggregateInput = TypedDict(
    'OrderCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'status': bool,
        'totalPrice': bool,
        'shippingAddress': bool,
        'deliveryOption': bool,
        'pickupLocation': bool,
        'trackingNumber': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

OrderCountAggregateOutput = TypedDict(
    'OrderCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'status': int,
        'totalPrice': int,
        'shippingAddress': int,
        'deliveryOption': int,
        'pickupLocation': int,
        'trackingNumber': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


OrderKeys = Literal[
    'id',
    'userId',
    'user',
    'status',
    'totalPrice',
    'shippingAddress',
    'deliveryOption',
    'pickupLocation',
    'trackingNumber',
    'createdAt',
    'updatedAt',
    'orderItems',
]
OrderScalarFieldKeys = Literal[
    'id',
    'userId',
    'status',
    'totalPrice',
    'shippingAddress',
    'deliveryOption',
    'pickupLocation',
    'trackingNumber',
    'createdAt',
    'updatedAt',
]
OrderScalarFieldKeysT = TypeVar('OrderScalarFieldKeysT', bound=OrderScalarFieldKeys)

OrderRelationalFieldKeys = Literal[
        'user',
        'orderItems',
    ]

# OrderItem types

class OrderItemOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the OrderItem create method"""
    id: _str
    orderId: _str
    order: 'OrderCreateNestedWithoutRelationsInput'
    productId: Optional[_str]
    product: 'ProductCreateNestedWithoutRelationsInput'
    petId: Optional[_str]
    pet: 'PetCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime


class OrderItemCreateInput(OrderItemOptionalCreateInput):
    """Required arguments to the OrderItem create method"""
    quantity: _int
    price: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class OrderItemOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the OrderItem create method, without relations"""
    id: _str
    orderId: _str
    productId: Optional[_str]
    petId: Optional[_str]
    createdAt: datetime.datetime


class OrderItemCreateWithoutRelationsInput(OrderItemOptionalCreateWithoutRelationsInput):
    """Required arguments to the OrderItem create method, without relations"""
    quantity: _int
    price: _float


class OrderItemCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'OrderItemCreateWithoutRelationsInput'
    connect: 'OrderItemWhereUniqueInput'


class OrderItemCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['OrderItemCreateWithoutRelationsInput', List['OrderItemCreateWithoutRelationsInput']]
    connect: Union['OrderItemWhereUniqueInput', List['OrderItemWhereUniqueInput']]


_OrderItemWhereUnique_id_Input = TypedDict(
    '_OrderItemWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

OrderItemWhereUniqueInput = _OrderItemWhereUnique_id_Input


class OrderItemUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    order: 'OrderUpdateOneWithoutRelationsInput'
    product: 'ProductUpdateOneWithoutRelationsInput'
    pet: 'PetUpdateOneWithoutRelationsInput'
    quantity: Union[AtomicIntInput, _int]
    price: Union[AtomicFloatInput, _float]
    createdAt: datetime.datetime


class OrderItemUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    quantity: Union[AtomicIntInput, _int]
    price: Union[AtomicFloatInput, _float]
    createdAt: datetime.datetime


class OrderItemUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['OrderItemCreateWithoutRelationsInput']
    connect: List['OrderItemWhereUniqueInput']
    set: List['OrderItemWhereUniqueInput']
    disconnect: List['OrderItemWhereUniqueInput']
    delete: List['OrderItemWhereUniqueInput']

    # TODO
    # update: List['OrderItemUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['OrderItemUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['OrderItemScalarWhereInput']
    # upsert: List['OrderItemUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['OrderItemCreateOrConnectWithoutRelationsInput']


class OrderItemUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'OrderItemCreateWithoutRelationsInput'
    connect: 'OrderItemWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'OrderItemUpdateInput'
    # upsert: 'OrderItemUpsertWithoutRelationsInput'
    # connectOrCreate: 'OrderItemCreateOrConnectWithoutRelationsInput'


class OrderItemUpsertInput(TypedDict):
    create: 'OrderItemCreateInput'
    update: 'OrderItemUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_OrderItem_id_OrderByInput = TypedDict(
    '_OrderItem_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_OrderItem_orderId_OrderByInput = TypedDict(
    '_OrderItem_orderId_OrderByInput',
    {
        'orderId': 'SortOrder',
    },
    total=True
)

_OrderItem_productId_OrderByInput = TypedDict(
    '_OrderItem_productId_OrderByInput',
    {
        'productId': 'SortOrder',
    },
    total=True
)

_OrderItem_petId_OrderByInput = TypedDict(
    '_OrderItem_petId_OrderByInput',
    {
        'petId': 'SortOrder',
    },
    total=True
)

_OrderItem_quantity_OrderByInput = TypedDict(
    '_OrderItem_quantity_OrderByInput',
    {
        'quantity': 'SortOrder',
    },
    total=True
)

_OrderItem_price_OrderByInput = TypedDict(
    '_OrderItem_price_OrderByInput',
    {
        'price': 'SortOrder',
    },
    total=True
)

_OrderItem_createdAt_OrderByInput = TypedDict(
    '_OrderItem_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

OrderItemOrderByInput = Union[
    '_OrderItem_id_OrderByInput',
    '_OrderItem_orderId_OrderByInput',
    '_OrderItem_productId_OrderByInput',
    '_OrderItem_petId_OrderByInput',
    '_OrderItem_quantity_OrderByInput',
    '_OrderItem_price_OrderByInput',
    '_OrderItem_createdAt_OrderByInput',
]



# recursive OrderItem types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

OrderItemRelationFilter = TypedDict(
    'OrderItemRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class OrderItemListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class OrderItemInclude(TypedDict, total=False):
    """OrderItem relational arguments"""
    order: Union[bool, 'OrderArgsFromOrderItem']
    product: Union[bool, 'ProductArgsFromOrderItem']
    pet: Union[bool, 'PetArgsFromOrderItem']


    

class UserIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderItemRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderItemRecursive1']
    orders: Union[bool, 'FindManyOrderArgsFromOrderItemRecursive1']


class UserIncludeFromOrderItemRecursive1(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderItemRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderItemRecursive2']
    orders: Union[bool, 'FindManyOrderArgsFromOrderItemRecursive2']


class UserIncludeFromOrderItemRecursive2(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderItemRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderItemRecursive3']
    orders: Union[bool, 'FindManyOrderArgsFromOrderItemRecursive3']


class UserIncludeFromOrderItemRecursive3(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderItemRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderItemRecursive4']
    orders: Union[bool, 'FindManyOrderArgsFromOrderItemRecursive4']


class UserIncludeFromOrderItemRecursive4(TypedDict, total=False):
    """Relational arguments for OrderItem"""

    

class UserArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    
    

class FindManyUserArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class PetIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderItemRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderItemRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItemRecursive1']


class PetIncludeFromOrderItemRecursive1(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderItemRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderItemRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItemRecursive2']


class PetIncludeFromOrderItemRecursive2(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderItemRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderItemRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItemRecursive3']


class PetIncludeFromOrderItemRecursive3(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderItemRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderItemRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItemRecursive4']


class PetIncludeFromOrderItemRecursive4(TypedDict, total=False):
    """Relational arguments for OrderItem"""

    

class PetArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'PetIncludeFromPetRecursive1'


class PetArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'PetIncludeFromPetRecursive2'


class PetArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'PetIncludeFromPetRecursive3'


class PetArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'PetIncludeFromPetRecursive4'


class PetArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    
    

class FindManyPetArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive1'


class FindManyPetArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive2'


class FindManyPetArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive3'


class FindManyPetArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    include: 'PetIncludeFromPetRecursive4'


class FindManyPetArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['PetOrderByInput', List['PetOrderByInput']]
    where: 'PetWhereInput'
    cursor: 'PetWhereUniqueInput'
    distinct: List['PetScalarFieldKeys']
    
    

class ProductIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderItemRecursive1']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderItemRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItemRecursive1']


class ProductIncludeFromOrderItemRecursive1(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderItemRecursive2']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderItemRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItemRecursive2']


class ProductIncludeFromOrderItemRecursive2(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderItemRecursive3']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderItemRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItemRecursive3']


class ProductIncludeFromOrderItemRecursive3(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    cartItems: Union[bool, 'FindManyCartItemArgsFromOrderItemRecursive4']
    wishlistItems: Union[bool, 'FindManyWishlistArgsFromOrderItemRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItemRecursive4']


class ProductIncludeFromOrderItemRecursive4(TypedDict, total=False):
    """Relational arguments for OrderItem"""

    

class ProductArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'ProductIncludeFromProductRecursive1'


class ProductArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'ProductIncludeFromProductRecursive2'


class ProductArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'ProductIncludeFromProductRecursive3'


class ProductArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'ProductIncludeFromProductRecursive4'


class ProductArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    
    

class FindManyProductArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive1'


class FindManyProductArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive2'


class FindManyProductArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive3'


class FindManyProductArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive4'


class FindManyProductArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    
    

class CartItemIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    user: Union[bool, 'UserArgsFromOrderItemRecursive1']
    product: Union[bool, 'ProductArgsFromOrderItemRecursive1']
    pet: Union[bool, 'PetArgsFromOrderItemRecursive1']


class CartItemIncludeFromOrderItemRecursive1(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    user: Union[bool, 'UserArgsFromOrderItemRecursive2']
    product: Union[bool, 'ProductArgsFromOrderItemRecursive2']
    pet: Union[bool, 'PetArgsFromOrderItemRecursive2']


class CartItemIncludeFromOrderItemRecursive2(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    user: Union[bool, 'UserArgsFromOrderItemRecursive3']
    product: Union[bool, 'ProductArgsFromOrderItemRecursive3']
    pet: Union[bool, 'PetArgsFromOrderItemRecursive3']


class CartItemIncludeFromOrderItemRecursive3(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    user: Union[bool, 'UserArgsFromOrderItemRecursive4']
    product: Union[bool, 'ProductArgsFromOrderItemRecursive4']
    pet: Union[bool, 'PetArgsFromOrderItemRecursive4']


class CartItemIncludeFromOrderItemRecursive4(TypedDict, total=False):
    """Relational arguments for OrderItem"""

    

class CartItemArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'CartItemIncludeFromCartItemRecursive1'


class CartItemArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'CartItemIncludeFromCartItemRecursive2'


class CartItemArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'CartItemIncludeFromCartItemRecursive3'


class CartItemArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'CartItemIncludeFromCartItemRecursive4'


class CartItemArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    
    

class FindManyCartItemArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive1'


class FindManyCartItemArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive2'


class FindManyCartItemArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive3'


class FindManyCartItemArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    include: 'CartItemIncludeFromCartItemRecursive4'


class FindManyCartItemArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['CartItemOrderByInput', List['CartItemOrderByInput']]
    where: 'CartItemWhereInput'
    cursor: 'CartItemWhereUniqueInput'
    distinct: List['CartItemScalarFieldKeys']
    
    

class WishlistIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    user: Union[bool, 'UserArgsFromOrderItemRecursive1']
    product: Union[bool, 'ProductArgsFromOrderItemRecursive1']
    pet: Union[bool, 'PetArgsFromOrderItemRecursive1']


class WishlistIncludeFromOrderItemRecursive1(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    user: Union[bool, 'UserArgsFromOrderItemRecursive2']
    product: Union[bool, 'ProductArgsFromOrderItemRecursive2']
    pet: Union[bool, 'PetArgsFromOrderItemRecursive2']


class WishlistIncludeFromOrderItemRecursive2(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    user: Union[bool, 'UserArgsFromOrderItemRecursive3']
    product: Union[bool, 'ProductArgsFromOrderItemRecursive3']
    pet: Union[bool, 'PetArgsFromOrderItemRecursive3']


class WishlistIncludeFromOrderItemRecursive3(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    user: Union[bool, 'UserArgsFromOrderItemRecursive4']
    product: Union[bool, 'ProductArgsFromOrderItemRecursive4']
    pet: Union[bool, 'PetArgsFromOrderItemRecursive4']


class WishlistIncludeFromOrderItemRecursive4(TypedDict, total=False):
    """Relational arguments for OrderItem"""

    

class WishlistArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'WishlistIncludeFromWishlistRecursive1'


class WishlistArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'WishlistIncludeFromWishlistRecursive2'


class WishlistArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'WishlistIncludeFromWishlistRecursive3'


class WishlistArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'WishlistIncludeFromWishlistRecursive4'


class WishlistArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    
    

class FindManyWishlistArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive1'


class FindManyWishlistArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive2'


class FindManyWishlistArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive3'


class FindManyWishlistArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    include: 'WishlistIncludeFromWishlistRecursive4'


class FindManyWishlistArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['WishlistOrderByInput', List['WishlistOrderByInput']]
    where: 'WishlistWhereInput'
    cursor: 'WishlistWhereUniqueInput'
    distinct: List['WishlistScalarFieldKeys']
    
    

class OrderIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    user: Union[bool, 'UserArgsFromOrderItemRecursive1']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItemRecursive1']


class OrderIncludeFromOrderItemRecursive1(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    user: Union[bool, 'UserArgsFromOrderItemRecursive2']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItemRecursive2']


class OrderIncludeFromOrderItemRecursive2(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    user: Union[bool, 'UserArgsFromOrderItemRecursive3']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItemRecursive3']


class OrderIncludeFromOrderItemRecursive3(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    user: Union[bool, 'UserArgsFromOrderItemRecursive4']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItemRecursive4']


class OrderIncludeFromOrderItemRecursive4(TypedDict, total=False):
    """Relational arguments for OrderItem"""

    

class OrderArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'OrderIncludeFromOrderRecursive1'


class OrderArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'OrderIncludeFromOrderRecursive2'


class OrderArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'OrderIncludeFromOrderRecursive3'


class OrderArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'OrderIncludeFromOrderRecursive4'


class OrderArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    
    

class FindManyOrderArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive1'


class FindManyOrderArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive2'


class FindManyOrderArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive3'


class FindManyOrderArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive4'


class FindManyOrderArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    
    

class OrderItemIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    order: Union[bool, 'OrderArgsFromOrderItemRecursive1']
    product: Union[bool, 'ProductArgsFromOrderItemRecursive1']
    pet: Union[bool, 'PetArgsFromOrderItemRecursive1']


class OrderItemIncludeFromOrderItemRecursive1(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    order: Union[bool, 'OrderArgsFromOrderItemRecursive2']
    product: Union[bool, 'ProductArgsFromOrderItemRecursive2']
    pet: Union[bool, 'PetArgsFromOrderItemRecursive2']


class OrderItemIncludeFromOrderItemRecursive2(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    order: Union[bool, 'OrderArgsFromOrderItemRecursive3']
    product: Union[bool, 'ProductArgsFromOrderItemRecursive3']
    pet: Union[bool, 'PetArgsFromOrderItemRecursive3']


class OrderItemIncludeFromOrderItemRecursive3(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    order: Union[bool, 'OrderArgsFromOrderItemRecursive4']
    product: Union[bool, 'ProductArgsFromOrderItemRecursive4']
    pet: Union[bool, 'PetArgsFromOrderItemRecursive4']


class OrderItemIncludeFromOrderItemRecursive4(TypedDict, total=False):
    """Relational arguments for OrderItem"""

    

class OrderItemArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class OrderItemArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class OrderItemArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class OrderItemArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class OrderItemArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    
    

class FindManyOrderItemArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive1'


class FindManyOrderItemArgsFromOrderItemRecursive1(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive2'


class FindManyOrderItemArgsFromOrderItemRecursive2(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive3'


class FindManyOrderItemArgsFromOrderItemRecursive3(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItemRecursive4'


class FindManyOrderItemArgsFromOrderItemRecursive4(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    


FindManyOrderItemArgs = FindManyOrderItemArgsFromOrderItem
FindFirstOrderItemArgs = FindManyOrderItemArgsFromOrderItem


    

class OrderItemWhereInput(TypedDict, total=False):
    """OrderItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    orderId: Union[_str, 'types.StringFilter']
    order: 'OrderRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    price: Union[_float, 'types.FloatFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['OrderItemWhereInputRecursive1', List['OrderItemWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['OrderItemWhereInputRecursive1']
    OR: List['OrderItemWhereInputRecursive1']
    NOT: List['OrderItemWhereInputRecursive1']


class OrderItemWhereInputRecursive1(TypedDict, total=False):
    """OrderItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    orderId: Union[_str, 'types.StringFilter']
    order: 'OrderRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    price: Union[_float, 'types.FloatFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['OrderItemWhereInputRecursive2', List['OrderItemWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['OrderItemWhereInputRecursive2']
    OR: List['OrderItemWhereInputRecursive2']
    NOT: List['OrderItemWhereInputRecursive2']


class OrderItemWhereInputRecursive2(TypedDict, total=False):
    """OrderItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    orderId: Union[_str, 'types.StringFilter']
    order: 'OrderRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    price: Union[_float, 'types.FloatFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['OrderItemWhereInputRecursive3', List['OrderItemWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['OrderItemWhereInputRecursive3']
    OR: List['OrderItemWhereInputRecursive3']
    NOT: List['OrderItemWhereInputRecursive3']


class OrderItemWhereInputRecursive3(TypedDict, total=False):
    """OrderItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    orderId: Union[_str, 'types.StringFilter']
    order: 'OrderRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    price: Union[_float, 'types.FloatFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['OrderItemWhereInputRecursive4', List['OrderItemWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['OrderItemWhereInputRecursive4']
    OR: List['OrderItemWhereInputRecursive4']
    NOT: List['OrderItemWhereInputRecursive4']


class OrderItemWhereInputRecursive4(TypedDict, total=False):
    """OrderItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    orderId: Union[_str, 'types.StringFilter']
    order: 'OrderRelationFilter'
    productId: Union[None, _str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    petId: Union[None, _str, 'types.StringFilter']
    pet: 'PetRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    price: Union[_float, 'types.FloatFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate OrderItem types


    

class OrderItemScalarWhereWithAggregatesInput(TypedDict, total=False):
    """OrderItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    orderId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['OrderItemScalarWhereWithAggregatesInputRecursive1']
    OR: List['OrderItemScalarWhereWithAggregatesInputRecursive1']
    NOT: List['OrderItemScalarWhereWithAggregatesInputRecursive1']


class OrderItemScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """OrderItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    orderId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['OrderItemScalarWhereWithAggregatesInputRecursive2']
    OR: List['OrderItemScalarWhereWithAggregatesInputRecursive2']
    NOT: List['OrderItemScalarWhereWithAggregatesInputRecursive2']


class OrderItemScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """OrderItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    orderId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['OrderItemScalarWhereWithAggregatesInputRecursive3']
    OR: List['OrderItemScalarWhereWithAggregatesInputRecursive3']
    NOT: List['OrderItemScalarWhereWithAggregatesInputRecursive3']


class OrderItemScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """OrderItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    orderId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['OrderItemScalarWhereWithAggregatesInputRecursive4']
    OR: List['OrderItemScalarWhereWithAggregatesInputRecursive4']
    NOT: List['OrderItemScalarWhereWithAggregatesInputRecursive4']


class OrderItemScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """OrderItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    orderId: Union[_str, 'types.StringWithAggregatesFilter']
    productId: Union[_str, 'types.StringWithAggregatesFilter']
    petId: Union[_str, 'types.StringWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class OrderItemGroupByOutput(TypedDict, total=False):
    id: _str
    orderId: _str
    productId: _str
    petId: _str
    quantity: _int
    price: _float
    createdAt: datetime.datetime
    _sum: 'OrderItemSumAggregateOutput'
    _avg: 'OrderItemAvgAggregateOutput'
    _min: 'OrderItemMinAggregateOutput'
    _max: 'OrderItemMaxAggregateOutput'
    _count: 'OrderItemCountAggregateOutput'


class OrderItemAvgAggregateOutput(TypedDict, total=False):
    """OrderItem output for aggregating averages"""
    quantity: float
    price: float


class OrderItemSumAggregateOutput(TypedDict, total=False):
    """OrderItem output for aggregating sums"""
    quantity: _int
    price: _float


class OrderItemScalarAggregateOutput(TypedDict, total=False):
    """OrderItem output including scalar fields"""
    id: _str
    orderId: _str
    productId: _str
    petId: _str
    quantity: _int
    price: _float
    createdAt: datetime.datetime


OrderItemMinAggregateOutput = OrderItemScalarAggregateOutput
OrderItemMaxAggregateOutput = OrderItemScalarAggregateOutput


class OrderItemMaxAggregateInput(TypedDict, total=False):
    """OrderItem input for aggregating by max"""
    id: bool
    orderId: bool
    productId: bool
    petId: bool
    quantity: bool
    price: bool
    createdAt: bool


class OrderItemMinAggregateInput(TypedDict, total=False):
    """OrderItem input for aggregating by min"""
    id: bool
    orderId: bool
    productId: bool
    petId: bool
    quantity: bool
    price: bool
    createdAt: bool


class OrderItemNumberAggregateInput(TypedDict, total=False):
    """OrderItem input for aggregating numbers"""
    quantity: bool
    price: bool


OrderItemAvgAggregateInput = OrderItemNumberAggregateInput
OrderItemSumAggregateInput = OrderItemNumberAggregateInput


OrderItemCountAggregateInput = TypedDict(
    'OrderItemCountAggregateInput',
    {
        'id': bool,
        'orderId': bool,
        'productId': bool,
        'petId': bool,
        'quantity': bool,
        'price': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

OrderItemCountAggregateOutput = TypedDict(
    'OrderItemCountAggregateOutput',
    {
        'id': int,
        'orderId': int,
        'productId': int,
        'petId': int,
        'quantity': int,
        'price': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


OrderItemKeys = Literal[
    'id',
    'orderId',
    'order',
    'productId',
    'product',
    'petId',
    'pet',
    'quantity',
    'price',
    'createdAt',
]
OrderItemScalarFieldKeys = Literal[
    'id',
    'orderId',
    'productId',
    'petId',
    'quantity',
    'price',
    'createdAt',
]
OrderItemScalarFieldKeysT = TypeVar('OrderItemScalarFieldKeysT', bound=OrderItemScalarFieldKeys)

OrderItemRelationalFieldKeys = Literal[
        'order',
        'product',
        'pet',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields